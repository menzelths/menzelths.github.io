{"version":3,"file":"kurswahlMultiplatform.js","sources":["collections/Collections.kt","../../../../../src/commonMain/kotlin/sample/Sample.kt","generated/_Collections.kt","collections/Sets.kt","collections/Maps.kt","util/Standard.kt","text/Strings.kt","../../../../../src/commonMain/kotlin/sample/Tools.kt","generated/_Strings.kt","kotlin/string.kt","../../../../../src/jsMain/kotlin/sample/SampleJs.kt","org.w3c/org.w3c.dom.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n","package sample\n\nexpect class Sample() {\n    fun checkMe(): Int\n}\n\nexpect object Platform {\n    val name: String\n}\n\nexpect object Variablen {\n    var excludedList:MutableList<Int>\n\n}\n\n\nfun main() {\n\n    val f\u00e4cher: MutableList<Fach> = mutableListOf()\n    f\u00e4cher.add(Fach(\"Deutsch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Deutsch), 0,true))\n    f\u00e4cher.add(Fach(\"Englisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 1,true))\n    f\u00e4cher.add(Fach(\"Franz\u00f6sisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 2,false))\n    f\u00e4cher.add(Fach(\"Latein\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 3,false))\n    f\u00e4cher.add(Fach(\"Griechisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 4,false))\n    f\u00e4cher.add(Fach(\"Russisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 5,false))\n    f\u00e4cher.add(Fach(\"Spanisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 6,false))\n    f\u00e4cher.add(Fach(\"Italienisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 7,false))\n    f\u00e4cher.add(Fach(\"Portugiesisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 8,false))\n    f\u00e4cher.add(Fach(\"Chinesisch\", Aufgabenfeld.I, listOf(5, 3, 0), listOf(Fachattribute.Fremdsprache), 9,false))\n    f\u00e4cher.add(Fach(\"Bildende Kunst\", Aufgabenfeld.I, listOf(5, 2, 0), listOf(Fachattribute.MuKu), 10,true))\n    f\u00e4cher.add(Fach(\"Musik\", Aufgabenfeld.I, listOf(5, 2, 0), listOf(Fachattribute.MuKu), 11,true))\n    f\u00e4cher.add(Fach(\"Geschichte\", Aufgabenfeld.II, listOf(5, 2, 0), listOf(Fachattribute.Geschichte), 12,true))\n    f\u00e4cher.add(Fach(\"Geographie\", Aufgabenfeld.II, listOf(5, 0, 0), listOf(), 13,true))\n    f\u00e4cher.add(Fach(\"Gemeinschaftskunde\", Aufgabenfeld.II, listOf(5, 0, 0), listOf(), 14,true))\n    f\u00e4cher.add(Fach(\"Geo/Gk\", Aufgabenfeld.II, listOf(0, 2, 0), listOf(Fachattribute.GeGe), 15,true))\n    f\u00e4cher.add(Fach(\"Religionslehre\", Aufgabenfeld.II, listOf(5, 2, 0), listOf(), 17,true))\n    f\u00e4cher.add(Fach(\"Ethik\", Aufgabenfeld.II, listOf(5, 2, 0), listOf(), 18,true))\n    f\u00e4cher.add(Fach(\"Wirtschaft\", Aufgabenfeld.II, listOf(5, 0, 0), listOf(), 19,false))\n    f\u00e4cher.add(Fach(\"Mathematik\", Aufgabenfeld.III, listOf(5, 3, 0), listOf(Fachattribute.Mathematik), 20,true))\n    f\u00e4cher.add(Fach(\"Biologie\", Aufgabenfeld.III, listOf(5, 3, 0), listOf(Fachattribute.Naturwissenschaft), 21,true))\n    f\u00e4cher.add(Fach(\"Chemie\", Aufgabenfeld.III, listOf(5, 3, 0), listOf(Fachattribute.Naturwissenschaft), 22,true))\n    f\u00e4cher.add(Fach(\"Physik\", Aufgabenfeld.III, listOf(5, 3, 0), listOf(Fachattribute.Naturwissenschaft), 23,true))\n    f\u00e4cher.add(Fach(\"Schulversuch Informatik\", Aufgabenfeld.III,listOf(5, 3, 0),listOf(Fachattribute.kannNawiErsetzen), 24,false))\n    f\u00e4cher.add(Fach(\"Schulversuch NwT\", Aufgabenfeld.III, listOf(5, 3, 0), listOf(Fachattribute.kannNawiErsetzen), 25,false))\n    f\u00e4cher.add(Fach(\"Sport\", Aufgabenfeld.Sport, listOf(5, 2, 0), listOf(), 26,true))\n    f\u00e4cher.add(Fach(\"Literatur und Theater\", Aufgabenfeld.I, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 32,false))\n    f\u00e4cher.add(Fach(\"VK Mathematik\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 33,false))\n    f\u00e4cher.add(Fach(\"VK Sprache\", Aufgabenfeld.I, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 34,false))\n    f\u00e4cher.add(Fach(\"Wahlfach Informatik\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 35,false))\n    f\u00e4cher.add(Fach(\"Literatur\", Aufgabenfeld.I, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 36,false))\n    f\u00e4cher.add(Fach(\"Philosophie\", Aufgabenfeld.II, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 37,false))\n    f\u00e4cher.add(Fach(\"Psychologie\", Aufgabenfeld.II, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 38,false))\n    f\u00e4cher.add(Fach(\"Astronomie\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 39,false))\n    f\u00e4cher.add(Fach(\"Probleml\u00f6sen mit CAS\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 40,false))\n    f\u00e4cher.add(Fach(\"Darstellende Geometrie\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 41,false))\n    f\u00e4cher.add(Fach(\"Geologie\", Aufgabenfeld.III, listOf(0, 0, 2), listOf(Fachattribute.Orchidee), 42,false))\n    f\u00e4cher.add(Fach(\"Seminarfach I\", Aufgabenfeld.I, listOf(0, 3, 0), listOf(Fachattribute.Seminarfach), 27,false))\n    f\u00e4cher.add(Fach(\"Seminarfach II\", Aufgabenfeld.II, listOf(0, 3, 0), listOf(Fachattribute.Seminarfach), 28,false))\n    f\u00e4cher.add(Fach(\"Seminarfach III\", Aufgabenfeld.III, listOf(0, 3, 0), listOf(Fachattribute.Seminarfach), 29,false))\n\n    Belegung.f\u00e4cher = f\u00e4cher\n    Belegung.generiereF\u00e4cher(f\u00e4cher)\n\n    var aktuelleBelegung = Belegung(\"Belegung\")\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Mathematik\", Belegung.Companion.Kursart.LF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Englisch\", Belegung.Companion.Kursart.LF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Informatik\", Belegung.Companion.Kursart.LF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Geschichte\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Religionslehre\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.TOGGLEM\u00dcNDLICH, \"Religionslehre\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Deutsch\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.TOGGLEM\u00dcNDLICH, \"Deutsch\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Geo/Gk\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Sport\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Physik\", Belegung.Companion.Kursart.LF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Biologie\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Bildende Kunst\", Belegung.Companion.Kursart.BF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.NEU, \"Wahlfach Informatik\", Belegung.Companion.Kursart.WF)\n    aktuelleBelegung.action(Belegung.Companion.Aktion.TOGGLESTUNDEN, \"Wahlfach Informatik\", Belegung.Companion.Kursart.WF)\n\n\n    aktuelleBelegung.action(Belegung.Companion.Aktion.CHECK)\n\n    Belegung.belegungsObjekt = aktuelleBelegung\n\n\n\n    Sample().checkMe() // starte das Programm, das die Website aufbaut\n\n}\n\nclass Belegung(val name: String) {\n\n    abstract class Zeile\n\n    data class \u00dcberschrift(\n        val text: String\n    ) : Zeile()\n\n    enum class Kommentarart {\n        GUT, SCHLECHT, NEUTRAL\n    }\n\n    data class Summe(\n        val stunden: List<Int>\n    ) : Zeile()\n\n    data class Kommentar(\n\n        val kommentarart: Kommentarart,\n        val text: String\n    ) : Zeile()\n\n    data class ZeileDarstellung(\n        val name: String,\n        val aufgabenfeld: Aufgabenfeld,\n        val gew\u00e4hlt: Kursart?,\n        val klickbar: Set<Kursart>,\n        val m\u00fcndlich: Boolean,\n        val m\u00fcndlichKlickbar: Boolean,\n        val stunden: List<Int>,\n        val stundenAlternativVorhanden: Boolean,\n        val fachnameOriginal: String,\n        val anrechnungspflichtig:List<Int>\n\n    ) : Zeile()\n\n    private fun anzahlLeistungsf\u00e4cher() = aktuelleBelegung.filter { it.typ == Kursart.LF }.count()\n    private fun anzahlM\u00fcndlichePr\u00fcfungen() =\n        aktuelleBelegung.filter { it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung) }.count()\n\n    private fun seminarFachGew\u00e4hlt(): Aufgabenfeld? {\n        val sf = aktuelleBelegung.filter { it.attribute.contains(Fachattribute.Seminarfach) }.firstOrNull()\n        if (sf != null) {\n            return sf.aufgabenfeld\n        }\n        return null\n    }\n\n    private fun fachAlsBasisfachOderWahlfachGew\u00e4hlt(fach: String): Boolean {\n        return aktuelleBelegung.filter { it.name == fach }.filter { it.typ == Kursart.BF || it.typ == Kursart.WF }.count() > 0\n    }\n\n    private fun alleHalbjahreBelegt(fach: String, typ: Kursart): Boolean {\n        val fach = aktuelleBelegung.filter { it.name == fach && it.typ == typ }.firstOrNull()\n        if (fach != null) {\n\n            if (fach.alternativStunden) {\n                return fach.stundenAlternativ.filter { it != 0 }.count() == 4\n            } else {\n                return fach.stunden.filter { it != 0 }.count() == 4\n            }\n        } else {\n            return false\n        }\n\n    }\n\n\n    public fun holeFehler(): List<Kommentar> {\n        this.action(Aktion.CHECK)\n        return fehlerMeldungen.toList()\n    }\n\n    public fun getBelegung(): MutableList<Belegfach> {\n        return aktuelleBelegung\n    }\n\n    public fun holeDarstellung(): List<Zeile> {\n        var text = mutableSetOf<Zeile>()\n        val bereiche = f\u00e4cherauswahl.filter{!Variablen.excludedList.contains(it.id)}.groupBy { it.aufgabenfeld }\n\n        for (bereich in bereiche) {\n            text.add(\u00dcberschrift(\"Bereich \" + bereich.key))\n            val f\u00e4cher = bereich.value.groupBy { it.name }\n            for (f in f\u00e4cher) {\n                val aufgabenfeld = bereich.key\n\n                lateinit var name: String\n                var gew\u00e4hlt: Kursart? = null\n                var m\u00fcndlich = false\n                var m\u00fcndlichKlickbar = false\n                var klickbarWahl = mutableSetOf<Kursart>()\n                var stunden = mutableListOf<Int>()\n                var stundenAlternativVorhanden = false\n                var anrechnung= mutableListOf<Int>(0,0,0,0)\n                name = f.key\n                val fachnameOriginal = f.key\n                val varianten = f.value\n                for (v in varianten) {\n                    if (anzahlLeistungsf\u00e4cher() < 3\n                        && !v.attribute.contains(Fachattribute.Orchidee) // Wahlfach hat kein LF\n                        && !v.attribute.contains(Fachattribute.Seminarfach) // Seminarfach ist kein LF\n                        && !v.attribute.contains(Fachattribute.GeGe)\n                    ) { // GeGe gibt es nicht als LF\n                        klickbarWahl.add(Kursart.LF)\n                    }\n                    if (aktuelleBelegung.contains(v)) {\n                        gew\u00e4hlt = v.typ\n                        if (v.attribute.contains(Fachattribute.Seminarfach)) {\n\n                        }\n                        klickbarWahl.add(v.typ)\n                        stunden = if (v.alternativStunden == false) v.stunden else v.stundenAlternativ\n                        if (v.typ == Kursart.WF) {\n                            stundenAlternativVorhanden = true\n                        }\n                        if (v.typ == Kursart.BF && v.attribute.contains(Fachattribute.sp\u00e4tbeginnend)) {\n                            stundenAlternativVorhanden = true\n                        }\n                        if (v.attribute.contains(Fachattribute.GeGe)) {\n                            v.stunden = mutableListOf(2, 2, 2, 2)\n\n                            if (aktuelleBelegung.filter { it.name == \"Wirtschaft\" && it.typ == Kursart.LF }.count() > 0) {\n                                stundenAlternativVorhanden = true\n                            }\n                            if (aktuelleBelegung.filter { it.name == \"Gemeinschaftskunde\" && it.typ == Kursart.LF }.count() > 0) {\n                                stundenAlternativVorhanden = false\n                                v.stunden = mutableListOf(2, 0, 0, 2)\n                                name = \"Geographie\"\n                                stunden = v.stunden\n\n                            }\n                            if (aktuelleBelegung.filter { it.name == \"Geographie\" && it.typ == Kursart.LF }.count() > 0) {\n                                stundenAlternativVorhanden = false\n                                v.stunden = mutableListOf(0, 2, 2, 0)\n                                stunden = v.stunden\n                                name = \"Gemeinschaftskunde\"\n                            }\n                        }\n\n                        if (Belegung.holeKurswahlKorrekt()){\n                            val stelle=Belegung.anrechnungspflichtig.filter{it.id==v.id}.firstOrNull()\n                            if (stelle!=null){\n                                anrechnung=stelle.stunden.toMutableList()\n                            }\n                        }\n\n                    }\n\n                    // falls Gemeinschaftskunde oder Geographie als LK, dann Geo/Gk zu geo bzw. gk\n                    if (v.attribute.contains(Fachattribute.GeGe)) {\n                        if (aktuelleBelegung.filter { it.name == \"Gemeinschaftskunde\" && it.typ == Kursart.LF }.count() > 0) {\n                            name = \"Geographie\"\n                        }\n                        if (aktuelleBelegung.filter { it.name == \"Geographie\" && it.typ == Kursart.LF }.count() > 0) {\n                            name = \"Gemeinschaftskunde\"\n                        }\n                    }\n\n                    if (v.typ == Kursart.BF || v.typ == Kursart.WF) {\n                        if (v.attribute.contains(Fachattribute.Seminarfach) && seminarFachGew\u00e4hlt() == v.aufgabenfeld) {\n                            klickbarWahl.add(v.typ)\n                        } else if (v.attribute.contains(Fachattribute.Seminarfach) && seminarFachGew\u00e4hlt() != null && seminarFachGew\u00e4hlt() != v.aufgabenfeld) {\n                            klickbarWahl.remove(v.typ)\n                        } else {\n                            klickbarWahl.add(v.typ)\n                        }\n                        if (anzahlM\u00fcndlichePr\u00fcfungen() < 2 && fachAlsBasisfachOderWahlfachGew\u00e4hlt(v.name) && alleHalbjahreBelegt(\n                                v.name,\n                                v.typ\n                            )\n                        ) {\n                            m\u00fcndlichKlickbar = true\n                        }\n                        if (v.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                            m\u00fcndlichKlickbar = true\n                            m\u00fcndlich = true\n                        }\n                    }\n                }\n\n\n\n\n\n                text.add(\n                    ZeileDarstellung(\n                        name,\n                        aufgabenfeld,\n                        gew\u00e4hlt,\n                        klickbarWahl,\n                        m\u00fcndlich,\n                        m\u00fcndlichKlickbar,\n                        stunden,\n                        stundenAlternativVorhanden,\n                        fachnameOriginal,\n                        anrechnung\n                    )\n                )\n            }\n        }\n        text.add(Summe(holeWochenStunden()))\n        return text.toList()\n    }\n\n    public fun getF\u00e4cher(): List<Belegfach> {\n        return f\u00e4cherauswahl\n    }\n\n    override fun toString(): String {\n        return \"\\n\\nAktuelleBelegung:\\n\" + aktuelleBelegung.map { it -> \"${it.name} ${it.typ} ${it.attribute}\" }.joinToString(\n            separator = \"\\n\"\n        )\n    }\n\n    private val aktuelleBelegung: MutableList<Belegfach> = mutableListOf()\n\n    private fun testeMehrfach(): Boolean {\n        val mehrfach = aktuelleBelegung.groupBy { it: Belegfach -> it.name }.filterValues { it.size > 1 }.keys.toList()\n        if (mehrfach.size > 0) {\n            println(\"Die folgenden F\u00e4cher sind mehrfach belegt: ${mehrfach.joinToString(separator = \",\")}\")\n            return false\n        } else {\n            return true\n        }\n    }\n\n    private fun testeSprachenOderNaturwissenschaft(): Boolean {\n        // Es m\u00fcssen zwei Sprachen oder zwei Naturwissenschaften abgedeckt sein\n        val sprachen = aktuelleBelegung.filter { it.attribute.contains(Fachattribute.Fremdsprache) }\n        val naturwissenschaften = aktuelleBelegung.filter {\n            it.attribute.contains(Fachattribute.Naturwissenschaft) || it.attribute.contains(Fachattribute.kannNawiErsetzen)\n        }\n        val naturwissenschaftersatz = aktuelleBelegung.filter { it.attribute.contains(Fachattribute.kannNawiErsetzen) }\n        val kommentarart=if (sprachen.count()>0&&naturwissenschaften.count()>0&&sprachen.count()+naturwissenschaften.count()>2) Kommentarart.GUT else Kommentarart.SCHLECHT\n        println(\"${sprachen.count()} Sprache(n) und ${naturwissenschaften.count()} Naturwissenschaft(en) gew\u00e4hlt.\")\n        fehlerMeldungen.add(\n            Kommentar(\n                 kommentarart,\n                \"${sprachen.count()} Sprache(n) und ${naturwissenschaften.count()} Naturwissenschaft(en) gew\u00e4hlt.\"\n            )\n        )\n\n        if (sprachen.count() == 0 || naturwissenschaften.count() == 0) {\n            println(\"Es wurde noch keine Fremdsprache gew\u00e4hlt.\")\n            if (naturwissenschaften.count() - naturwissenschaftersatz.count() == 0) {\n                fehlerMeldungen.add(\n                    Kommentar(\n                        Kommentarart.SCHLECHT,\n                        \"Es wurde noch keine klassische Naturwissenschaft gew\u00e4hlt.\"\n                    )\n                )\n            }\n            if (sprachen.count() == 0) {\n                fehlerMeldungen.add(Kommentar(Kommentarart.SCHLECHT, \"Es wurde noch keine Fremdsprache gew\u00e4hlt.\"))\n            }\n            return false\n        }\n\n        if (sprachen.count() < 2 && naturwissenschaften.count() < 2) {\n            println(\"Es m\u00fcssen entweder mindestens 2 Naturwissenschaften und 1 Sprache belegt werden oder umgekehrt.\")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Es m\u00fcssen entweder mindestens 2 Naturwissenschaften und 1 Sprache belegt werden oder umgekehrt.\"\n                )\n            )\n            return false\n        } else if (sprachen.count() < 2 && naturwissenschaften.count() >= 2) {\n            // es m\u00fcssen zwei Naturwissenschaften dabei sein\n            val anzahlKlassischeNaturwissenschaften = naturwissenschaften.count() - naturwissenschaftersatz.count()\n            if (anzahlKlassischeNaturwissenschaften == 0) {\n                println(\"Es muss mindestens eine klassische Naturwissenschaft belegt werden.\")\n                fehlerMeldungen.add(\n                    Kommentar(\n                        Kommentarart.SCHLECHT,\n                        \"Es muss mindestens eine klassische Naturwissenschaft belegt werden.\"\n                    )\n                )\n                return false\n            } else if (anzahlKlassischeNaturwissenschaften == 1) {\n                val anzahlLeistungsf\u00e4cher = naturwissenschaften.filter { it.typ == Kursart.LF }.count()\n                if (anzahlLeistungsf\u00e4cher > 0) {\n                    println(\"G\u00fcltige Kombination f\u00fcr Naturwissenschaften\")\n                    fehlerMeldungen.add(Kommentar(Kommentarart.GUT, \"G\u00fcltige Kombination f\u00fcr Naturwissenschaften.\"))\n                    return true\n                } else {\n                    println(\"Bei der Ersetzung einer klassischen Naturwissenschaft durch Informatik oder NwT muss mindestens eines dieser F\u00e4cher als Leistungsfach belegt werden.\")\n                    fehlerMeldungen.add(\n                        Kommentar(\n                            Kommentarart.SCHLECHT,\n                            \"Bei der Ersetzung einer klassischen Naturwissenschaft durch Informatik oder NwT muss mindestens eines dieser F\u00e4cher als Leistungsfach belegt werden.\"\n                        )\n                    )\n                    return false\n                }\n            } else {\n                return true\n            }\n        } else {\n            return true\n        }\n    }\n\n    private fun testeObFachSchonVorhanden(name: String): Boolean {\n        val anzahl = aktuelleBelegung.filter { it.name == name }.count()\n        return anzahl > 0\n    }\n\n    private fun testeBereichsabdeckungPr\u00fcfung(): Boolean {\n        var rueckgabe = false\n        val pr\u00fcfungsf\u00e4cher =\n            aktuelleBelegung.filter { it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung) || it.typ == Kursart.LF }\n        if ((pr\u00fcfungsf\u00e4cher.filter { it.attribute.contains(Fachattribute.Deutsch) || it.attribute.contains(Fachattribute.Mathematik) }.count() < 2)) {\n            println(\"Mathematik und Deutsch m\u00fcssen Pr\u00fcfungsf\u00e4cher im Abitur sein.\")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Mathematik und Deutsch m\u00fcssen Pr\u00fcfungsf\u00e4cher im Abitur sein.\"\n                )\n            )\n            return false\n        } else {\n            print(\"Mathematik und Deutsch sind in den Pr\u00fcfungsf\u00e4chern enthalten. \")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.GUT,\n                    \"Mathematik und Deutsch sind in den Pr\u00fcfungsf\u00e4chern enthalten. \"\n                )\n            )\n            rueckgabe = true\n        }\n        if (pr\u00fcfungsf\u00e4cher.count() < 5) {\n            println(\"Es m\u00fcssen drei Leistungsf\u00e4cher f\u00fcr die schriftliche und zwei Basisf\u00e4cher f\u00fcr die m\u00fcndliche Pr\u00fcfung gew\u00e4hlt werden\")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Es m\u00fcssen drei Leistungsf\u00e4cher f\u00fcr die schriftliche und zwei Basisf\u00e4cher f\u00fcr die m\u00fcndliche Pr\u00fcfung gew\u00e4hlt werden.\"\n                )\n            )\n            return false\n        } else {\n            println(\"Es sind drei Leistungsf\u00e4cher und f\u00fcr die m\u00fcndliche Pr\u00fcfung zwei Basisf\u00e4cher gew\u00e4hlt\")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.GUT,\n                    \"Es sind f\u00fcr die Abiturpr\u00fcfung drei Leistungsf\u00e4cher und zwei m\u00fcndliche Pr\u00fcfungsf\u00e4cher gew\u00e4hlt.\"\n                )\n            )\n            rueckgabe = true\n        }\n\n        val bereiche = pr\u00fcfungsf\u00e4cher.map { it -> it.aufgabenfeld }.toSet()\n        val fehlendeBereiche = setOf(Aufgabenfeld.I, Aufgabenfeld.II, Aufgabenfeld.III).minus(bereiche)\n        if (fehlendeBereiche.size > 0) {\n            println(\n                \"Die folgenden Aufgabenfelder sind noch nicht in der Abiturpr\u00fcfung abgedeckt: ${fehlendeBereiche.map { Text[it] }.joinToString(\n                    separator = \",\"\n                )}.\"\n            )\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Die folgenden Aufgabenfelder sind noch nicht in der Abiturpr\u00fcfung abgedeckt: ${fehlendeBereiche.map { Text[it] }.joinToString(\n                        separator = \",\"\n                    )}.\"\n                )\n            )\n            return false\n        }\n        return rueckgabe\n    }\n\n\n    private fun testePflichtbelegungRest(): Boolean {\n        var pflichtf\u00e4cher = mutableListOf<Int>()\n        val Bereichsnamen = listOf(\n            \"Geschichte\",\n            \"Geographie und Gemeinschaftskunde\",\n            \"Religion oder Ethik\",\n            \"Bildende Kunst oder Musik\",\n            \"Sport\"\n        )\n        with(aktuelleBelegung) {\n            pflichtf\u00e4cher.add(filter { it.name == \"Geschichte\" }.count())\n            pflichtf\u00e4cher.add(filter { it.attribute.contains(Fachattribute.GeGe) }.count())\n            pflichtf\u00e4cher.add(filter { it.name == \"Religionslehre\" || it.name == \"Ethik\" }.count())\n            pflichtf\u00e4cher.add(filter { it.name == \"Bildende Kunst\" || it.name == \"Musik\" }.count())\n            pflichtf\u00e4cher.add(filter { it.name == \"Sport\" }.count())\n        }\n        var fehlendeF\u00e4cher = mutableListOf<String>()\n        for ((index, pf) in pflichtf\u00e4cher.withIndex()) {\n            if (pf == 0) {\n                fehlendeF\u00e4cher.add(Bereichsnamen[index])\n            }\n        }\n        if (fehlendeF\u00e4cher.size > 0) {\n            println(\"Folgende F\u00e4cher fehlen noch: ${fehlendeF\u00e4cher.joinToString(separator = \", \")}.\")\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Folgende F\u00e4cher fehlen noch: ${fehlendeF\u00e4cher.joinToString(separator = \", \")}.\"\n                )\n            )\n        }\n        return fehlendeF\u00e4cher.size == 0\n    }\n\n\n    private fun testeMindestens42Kurse(): Boolean {\n        var kurssumme = 0\n        for (fach in aktuelleBelegung) {\n            kurssumme += if (fach.alternativStunden == false) fach.stunden.filter { it != 0 }.count() else fach.stundenAlternativ.filter { it != 0 }.count()\n        }\n        println(\"Anzahl der gew\u00e4hlten Kurse: $kurssumme\")\n        if (kurssumme<42) {\n            fehlerMeldungen.add(Kommentar(Kommentarart.SCHLECHT, \"Anzahl der gew\u00e4hlten Kurse: $kurssumme. Es m\u00fcssen jedoch mindestens 42 Kurse gew\u00e4hlt werden.\"))\n        }\n        if (kurssumme >=42) {\n            fehlerMeldungen.add(Kommentar(Kommentarart.GUT, \"Mit $kurssumme belegten Kursen ist die Bedingung von mindestens 42 belegten Kursen erf\u00fcllt.\"))\n        }\n        return kurssumme >= 42\n    }\n\n    private fun testeAnrechnungspflichtigeStunden(): Boolean {\n        var mukuSchonGepr\u00fcft = false\n        var kurssumme = 0\n        var nawiSprZ\u00e4hler=0\n        Belegung.anrechnungspflichtig= mutableListOf()\n\n        if (aktuelleBelegung.filter{it.attribute.contains(Fachattribute.MuKu) && it.typ==Kursart.LF}.count()>0){\n            mukuSchonGepr\u00fcft=true\n        }\n        if (aktuelleBelegung.filter{it.attribute.contains(Fachattribute.MuKu) && it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)}.count()>0){\n            mukuSchonGepr\u00fcft=true\n        }\n\n        for (f in aktuelleBelegung) {\n\n\n            if (f.typ == Kursart.LF) {\n                kurssumme += 4\n                Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1, 1, 1, 1)))\n                if (f.attribute.contains(Fachattribute.Naturwissenschaft) || f.attribute.contains(Fachattribute.kannNawiErsetzen)) {\n                nawiSprZ\u00e4hler+=1\n                }\n\n                } else if (f.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)){\n                kurssumme += 4\n                Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1, 1, 1, 1)))\n\n            } else if (f.typ == Kursart.BF) {\n                if (f.attribute.contains(Fachattribute.Geschichte)) {\n                    kurssumme += 4\n                    Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,1,1)))\n                } else if (f.attribute.contains(Fachattribute.MuKu) && !mukuSchonGepr\u00fcft) {\n                    kurssumme += 2\n                    Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,0,0)))\n                    mukuSchonGepr\u00fcft = true\n                } else if (f.attribute.contains(Fachattribute.Naturwissenschaft) || f.attribute.contains(Fachattribute.kannNawiErsetzen)) {\n                    if (nawiSprZ\u00e4hler<3) {\n                        kurssumme += 4\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1, 1, 1, 1)))\n                        nawiSprZ\u00e4hler += 1\n                    }\n                    } else if (f.attribute.contains(Fachattribute.Fremdsprache)) {\n                    if (f.alternativStunden) {\n                        kurssumme += 2\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,0,0)))\n                    } else {\n                        if (nawiSprZ\u00e4hler<3) {\n                            kurssumme += 4\n                            Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1, 1, 1, 1)))\n                            nawiSprZ\u00e4hler += 1\n                        }\n                    }\n                } else if (f.attribute.contains(Fachattribute.GeGe)) {\n                    if (aktuelleBelegung.filter { it.name == \"Gemeinschaftskunde\" && it.typ == Kursart.LF }.count() > 0) {\n                        kurssumme += 2\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,0,0,1)))\n\n                    } else if (aktuelleBelegung.filter { it.name == \"Geographie\" && it.typ == Kursart.LF }.count() > 0) {\n                        kurssumme += 2\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(0,1,1,0)))\n                    } else if (aktuelleBelegung.filter { it.name == \"Wirtschaft\" && it.typ == Kursart.LF }.count() > 0) {\n                        kurssumme += 2\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,0,1,0)))\n                    } else {\n                        Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,1,1)))\n                        kurssumme += 4\n                    }\n                } else if (f.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) { // andere Basisf\u00e4cher als m\u00fcndliche Pr\u00fcfung\n                    kurssumme += 4\n                    Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,1,1)))\n                }\n\n            }/* else if (f.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) { //WF in m\u00fcndlicher Pr\u00fcfung\n                kurssumme += 4\n                Belegung.anrechnungspflichtig.add(Anrechnung(f.id, mutableListOf(1,1,1,1)))\n            }*/\n        }\n\n        if (kurssumme == 40) {\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.GUT,\n                    \"Es sind genau 40 anrechnungspflichtige Kurse in der Belegung vorhanden.\"\n                )\n            )\n        } else if (kurssumme < 40) {\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.GUT,\n                    \"Es sind mit $kurssumme weniger als 40 anrechnungspflichtige Kurse in der Belegung vorhanden. Somit k\u00f6nnen neben den anrechnungspflichtigen Kursen noch ${40-kurssumme} Kurse aus der aktuellen Auswahl angerechnet werden.\"\n                )\n            )\n\n        } else if (kurssumme > 40) {\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Es sind mit $kurssumme mehr als 40 anrechnungspflichtige Kurse in der Belegung vorhanden.\"\n                )\n            )\n        }\n        Belegung.anrechnungspflichtig.forEach {\n            val wert=it\n            val fachname= f\u00e4cher.filter { it.id==wert.id}.first().name\n            println(\"$fachname ${it.stunden}\")\n        }\n        return kurssumme <= 40\n    }\n\n    private fun holeWochenStunden(): List<Int> {\n        var stundensumme = mutableListOf<Int>(0, 0, 0, 0)\n        var zeilenStunden = mutableListOf<Int>()\n        for (fach in aktuelleBelegung) {\n            zeilenStunden = if (fach.alternativStunden == false) fach.stunden else fach.stundenAlternativ\n            for (i in 0..3) {\n                stundensumme[i] += zeilenStunden[i]\n            }\n        }\n        return stundensumme.toList()\n    }\n\n    private fun testeMindestens32Wochenstunden(): Boolean {\n        var stundensumme = 0\n        for (fach in aktuelleBelegung) {\n            stundensumme += if (fach.alternativStunden == false) fach.stunden.sum() else fach.stundenAlternativ.sum()\n        }\n        val durchschnitt = stundensumme.toDouble() / 4.0\n        println(\"Durchschnittlich $durchschnitt Wochenstunden pro Halbjahr.\")\n        fehlerMeldungen.add(\n            Kommentar(\n                Kommentarart.NEUTRAL,\n                \"Durchschnittlich $durchschnitt Wochenstunden pro Halbjahr.\"\n            )\n        )\n\n        if (durchschnitt < 32) {\n            fehlerMeldungen.add(\n                Kommentar(\n                    Kommentarart.SCHLECHT,\n                    \"Es m\u00fcssen im Durchschnitt mindestens 32 Wochenstunden pro Halbjahr sein.\\nSomit m\u00fcssen noch Kurse im Gesamtwochenstundenumfang von mindestens ${(32 - durchschnitt) * 4} Stunden belegt werden.\"\n                )\n            )\n            println(\"\\nEs m\u00fcssen im Durchschnitt mindestens 32 Wochenstunden pro Halbjahr sein.\")\n            println(\"\\nSomit m\u00fcssen noch Kurse im Gesamtwochenstundenumfang von mindestens ${(32 - durchschnitt) * 4} Stunden belegt werden.\")\n        }\n        return durchschnitt >= 32\n    }\n\n    private fun testeLeistungsf\u00e4cher(): Boolean {\n        val leistungsf\u00e4cher = aktuelleBelegung.filter { it.typ == Kursart.LF }\n        var r\u00fcckgabe = false\n        if (leistungsf\u00e4cher.size < 3) {\n            println(\"Zu wenige Leistungsf\u00e4cher gew\u00e4hlt!\")\n            fehlerMeldungen.add(Kommentar(Kommentarart.SCHLECHT, \"Zu wenige Leistungsf\u00e4cher gew\u00e4hlt.\"))\n        } else if (leistungsf\u00e4cher.size > 3) {\n            println(\"Zu viele Leistungsf\u00e4cher gew\u00e4hlt!\")\n            fehlerMeldungen.add(Kommentar(Kommentarart.SCHLECHT, \"Zu viele Leistungsf\u00e4cher gew\u00e4hlt.\"))\n        } else { // genau drei Leistungsf\u00e4cher\n            val lfAuswahl = leistungsf\u00e4cher.groupBy { it.attribute }.keys.flatten().toSet()\n\n            if ((leistungsfachBereiche.minus(lfAuswahl).size) <= 2) {\n                println(\"Leistungsfachkombination g\u00fcltig\")\n                fehlerMeldungen.add(Kommentar(Kommentarart.GUT, \"Leistungsfachkombination g\u00fcltig.\"))\n                r\u00fcckgabe = true\n            } else {\n                println(\"Leistungsfachkombination ung\u00fcltig: zwei der drei Leistungsf\u00e4cher m\u00fcssen aus D, M, FS, Nawi sein.\")\n                fehlerMeldungen.add(\n                    Kommentar(\n                        Kommentarart.SCHLECHT,\n                        \"Leistungsfachkombination ung\u00fcltig: zwei der drei Leistungsf\u00e4cher m\u00fcssen aus D, M, FS, Nawi sein.\"\n                    )\n                )\n            }\n        }\n\n        return r\u00fcckgabe\n    }\n\n    fun serialisiere(): String {\n        var kodierung = \"\"\n        for (f in aktuelleBelegung) {\n            var id = f.id.toString(2)\n            id = \"0\".repeat(6 - id.length) + id\n\n            var typ = \"00\"\n            if (f.typ == Kursart.LF) {\n                typ = \"00\"\n            } else if (f.typ == Kursart.BF) {\n                if (f.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                    typ = \"01\"\n                } else {\n                    typ = \"10\"\n                }\n            } else if (f.typ == Kursart.WF && f.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                typ = \"11\"\n            } else {\n                println(\"Das darf nicht sein!\")\n            }\n\n            val alternativ = if (f.alternativStunden) \"1\" else \"0\"\n\n            kodierung += id + typ + alternativ\n        }\n        return Kodierung.binarystring2Characterstring(kodierung)\n    }\n\n    fun deserialisiere(input: String) {\n        while (aktuelleBelegung.size > 0) {\n            aktuelleBelegung.removeAt(0)\n        }\n        Belegung.f\u00e4cherauswahl = mutableListOf<Belegfach>()\n        Belegung.f\u00e4cher.forEach { }\n        generiereF\u00e4cher(Belegung.f\u00e4cher)\n\n        val kombination = Kodierung.characterstring2Binarystring(input).cut(9)\n        for (k in kombination) {\n            println(\"Kombination $k\")\n            val fachnummer = Kodierung.binarystring2Int(k.substring(0..5)).toInt()\n\n            val typ = k.substring(6..7)\n            val alternativ = if (k.last().equals('1')) true else false\n\n\n            println(\"$fachnummer, $typ, $alternativ\")\n\n            val fachname = f\u00e4cher.filter { it.id == fachnummer }.first().name\n\n            var fachtyp = Kursart.WF\n\n\n            var m\u00fcndlich = false\n            if (fachnummer < 32) { //BF oder LF\n                if (typ == \"00\") {\n                    fachtyp = Kursart.LF\n                    m\u00fcndlich = false\n                } else if (typ == \"10\") {\n                    fachtyp = Kursart.BF\n                    m\u00fcndlich = false\n                } else if (typ == \"01\") {\n                    fachtyp = Kursart.BF\n                    m\u00fcndlich = true\n                }\n            } else { //WF\n                fachtyp = Kursart.WF\n                if (typ == \"11\") {\n                    m\u00fcndlich = true\n                }\n            }\n            belegungsObjekt.action(Aktion.NEU, fachname, fachtyp)\n\n            if (m\u00fcndlich) {\n                belegungsObjekt.action(Aktion.TOGGLEM\u00dcNDLICH, fachname, fachtyp)\n            }\n            if (alternativ) {\n                belegungsObjekt.action(Aktion.TOGGLESTUNDEN, fachname, fachtyp)\n            }\n        }\n    }\n\n    private fun fachBFoderLF(fachAktuell: Belegfach): String {\n        var kodierung = \"\"\n        if (fachAktuell.typ == Kursart.LF) {\n            kodierung += \"1\"\n\n        } else {\n            kodierung += \"0\"\n            // m\u00fcndliche Pr\u00fcfung: nein (0) oder ja (1)\n            if (fachAktuell.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                kodierung += \"1\"\n            } else {\n                kodierung += \"0\"\n            }\n        }\n        return kodierung\n    }\n\n    fun MutableList<Belegfach>.mehrfach(): List<String> {\n        val fachMap: MutableMap<String, Int> = mutableMapOf<String, Int>()\n        val mehrfach = this.groupBy { it: Belegfach -> it.name }.filterValues { it.size > 1 }.keys.toList()\n        println(this.groupBy { it: Belegfach -> it.name })\n        return mehrfach\n    }\n\n\n    fun action(command: Aktion, vararg parameter: Any) {\n        when (command) {\n            Aktion.NEU -> {\n                val name = parameter[0] as String // Name des Fachs\n                val typ = parameter[1] as Kursart // LF, BF oder WF?\n                val fach = f\u00e4cherauswahl.filter { it.name == name && it.typ == typ }.firstOrNull()\n\n                if (!testeObFachSchonVorhanden(name)) {\n                    if (fach != null) {\n                        if (!aktuelleBelegung.contains(fach)) {\n                            fach.attribute.remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                            fach.alternativStunden = false\n                            aktuelleBelegung.add(fach)\n\n                        } else {\n                            println(\"Fach $name bereits enthalten\")\n                            // fehlerMeldungen.add(Kommentar(true,\"Fach $name bereits enthalten\"))\n                        }\n                    } else {\n                        println(\"Fach existiert so nicht\")\n                        //fehlerMeldungen.add(Kommentar(true,\"Fach existiert so nicht\"))\n                    }\n                } else {\n                    println(\"Fach $name ist bereits in der Belegung vorhanden\")\n                    //fehlerMeldungen.add(Kommentar(true,\"Fach $name ist bereits in der Belegung vorhanden\"))\n                }\n            }\n\n            Aktion.L\u00d6SCHE -> {\n                val name = parameter[0] as String // Name des Fachs\n                aktuelleBelegung.removeAll { it.name == name }\n            }\n\n            Aktion.TOGGLESTUNDEN -> {\n                val name = parameter[0] as String // Name des Fachs\n                val typ = parameter[1] as Kursart // LF, BF oder WF?\n                val fach = aktuelleBelegung.filter { it.name == name && it.typ == typ }.firstOrNull()\n                if (fach != null) {\n                    fach.alternativStunden = !(fach.alternativStunden)\n                    if (fach.alternativStunden && fach.stundenAlternativ.filter { it > 0 }.count() < 4) {\n                        fach.attribute.remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                    }\n                }\n            }\n\n            Aktion.CHECK -> {\n                // 2 aus den LF aus Deutsch, Fremdsprache, Mathematik oder klassische Naturwissenschaft\n                fehlerMeldungen = mutableListOf()\n                Belegung.kurswahlKorrekt=false\n                Belegung.anrechnungspflichtig= mutableListOf()\n                var fehlerListe = mutableListOf<Boolean>()\n                fehlerListe.add(testeMehrfach())\n                fehlerListe.add(testeLeistungsf\u00e4cher())\n                fehlerListe.add(testeBereichsabdeckungPr\u00fcfung())\n                fehlerListe.add(testeSprachenOderNaturwissenschaft())\n                fehlerListe.add(testePflichtbelegungRest())\n                fehlerListe.add(testeMindestens42Kurse())\n                if (fehlerListe.filter { it == false }.count() == 0) {\n                    fehlerListe.add(testeAnrechnungspflichtigeStunden())\n                    if (fehlerListe.filter{it == false}.count()==0) {\n                        Belegung.kurswahlKorrekt = true\n                    }\n                }\n\n            }\n\n            Aktion.TOGGLEM\u00dcNDLICH -> {\n                val name = parameter[0] as String // Name des Fachs\n                val typ = parameter[1] as Kursart // LF, BF oder WF?\n                val anzahlPr\u00fcfungsf\u00e4cher =\n                    aktuelleBelegung.filter { it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung) }.count()\n                val schriftlichIndex = aktuelleBelegung.indexOfFirst { it.name == name && it.typ == typ }\n                if (schriftlichIndex >= 0) {\n                    with(aktuelleBelegung[schriftlichIndex].attribute) {\n                        if (contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                            remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                        } else {\n                            if (anzahlPr\u00fcfungsf\u00e4cher < 2) {\n                                add(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                            } else {\n                                fehlerMeldungen.add(\n                                    Kommentar(\n                                        Kommentarart.SCHLECHT,\n                                        \"Maximal drei m\u00fcndliche Pr\u00fcfungsf\u00e4cher erlaubt.\"\n                                    )\n                                )\n                                println(\"Maximal drei m\u00fcndliche Pr\u00fcfungsf\u00e4cher erlaubt.\")\n                            }\n                        }\n                    }\n                }\n            }\n\n            Aktion.TOGGLE -> {\n                val name = parameter[0] as String // Name des Fachs\n                val typ = parameter[1] as Kursart // LF, BF oder WF?\n                val fach = f\u00e4cherauswahl.filter { it.name == name && it.typ == typ }.firstOrNull()\n\n                if (fach != null) {\n                    with(aktuelleBelegung) {\n                        if (contains(fach)) { // Fach selber wird gel\u00f6scht\n                            fach.attribute.remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n\n                            removeAll { it.name == name }\n\n                            if (fach.name == \"Wirtschaft\" && fach.typ == Kursart.LF) {\n                                val gege =\n                                    f\u00e4cherauswahl.filter { it.attribute.contains(Fachattribute.GeGe) }.firstOrNull()\n                                if (gege != null) {\n                                    gege.alternativStunden = false\n                                    gege.attribute.remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                                }\n                            }\n                            fach.alternativStunden = false\n\n                        } else if (map { it -> it.name }.contains(name)) {\n                            f\u00e4cherauswahl.filter { it.name == name }.forEach {\n                                it.attribute.remove(Fachattribute.m\u00fcndlichePr\u00fcfung)\n                            }\n                            removeAll { it.name == name }\n                            fach.alternativStunden = false\n                            add(fach)\n                        } else {\n                            add(fach)\n                            fach.alternativStunden = false\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    companion object {\n\n        var kurswahlKorrekt=false\n\n        data class Anrechnung(val id:Int,val stunden:List<Int>)\n        var anrechnungspflichtig= mutableListOf<Anrechnung>()\n\n        fun holeKurswahlKorrekt():Boolean {\n            return kurswahlKorrekt\n        }\n\n        fun holeF\u00e4cher():List<Fach>{\n            return f\u00e4cher\n        }\n        lateinit var belegungsObjekt: Belegung\n        var aktuelleBelegung = mutableListOf<Belegfach>()\n        var f\u00e4cher = listOf<Fach>()\n\n        val bin\u00e4r2 = listOf<String>(\"00\", \"01\", \"10\", \"11\")\n        val bin\u00e4r3 = listOf<String>(\"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\")\n        val naturwissenschaften = listOf<String>(\"Physik\", \"Chemie\", \"Biologie\")\n        val sprachen = listOf<String>(\n            \"Englisch\",\n            \"Franz\u00f6sisch\",\n            \"Latein\",\n            \"Griechisch\",\n            \"Russisch\",\n            \"Spanisch\",\n            \"Italienisch\",\n            \"Portugiesisch\",\n            \"Chinesisch\"\n        )\n        val lfOderBfOderBfM\u00fcndlich = hashMapOf<String, String>(\"LF\" to \"10\", \"BF\" to \"01\", \"BFm\u00fcndlich\" to \"11\")\n        var fehlerMeldungen = mutableListOf<Kommentar>()\n        val Text = hashMapOf<Any, String>(\n            Kursart.BF to \"Basisfach\",\n            Aufgabenfeld.I to \"Sprachlich\",\n            Aufgabenfeld.II to \"Gesellschaftswissenschaften\",\n            Aufgabenfeld.III to \"Mathematik und Naturwissenschaften\"\n        )\n\n        enum class Kursart { LF, BF, WF }\n\n        fun getBelegungsobjekt(): Belegung {\n            return belegungsObjekt\n        }\n\n        val leistungsfachBereiche = setOf(\n            Fachattribute.Mathematik,\n            Fachattribute.Fremdsprache,\n            Fachattribute.Naturwissenschaft,\n            Fachattribute.Deutsch\n        )\n\n        enum class Aktion { NEU, L\u00d6SCHE, TOGGLE, CHECK, TOGGLEM\u00dcNDLICH, TOGGLESTUNDEN }\n        data class Belegfach(\n            val name: String,\n            val typ: Kursart,\n            var aufgabenfeld: Aufgabenfeld,\n            var stunden: MutableList<Int>,\n            val stundenAlternativ: MutableList<Int>,\n            var alternativStunden: Boolean,\n            var attribute: MutableList<Fachattribute>,\n            val id: Int\n        )\n\n        lateinit var f\u00e4cherauswahl: List<Belegfach>\n\n        fun generiereF\u00e4cher(listeMitF\u00e4chern: List<Fach>) {\n            val liste = mutableListOf<Belegfach>()\n            for (fach in listeMitF\u00e4chern) {\n                for (index in 0 until fach.stunden.size) {\n                    var stundenbelegung = mutableListOf<Int>()\n                    var stundenbelegungAlternativ = mutableListOf<Int>()\n                    if (fach.stunden.get(index) > 0) {\n                        for (i in 0..3) {\n                            stundenbelegung.add(fach.stunden.get(index))\n                        }\n\n                        val art = when (index) {\n                            0 -> Kursart.LF\n                            1 -> Kursart.BF\n                            else -> Kursart.WF\n                        }\n\n                        if (fach.attribute.contains(Fachattribute.Fremdsprache) && art == Kursart.BF) {\n                            stundenbelegungAlternativ = mutableListOf<Int>(4, 4, 4, 4) // sp\u00e4tbeginnende Fremdsprache\n                            val attr2 = fach.attribute.toMutableList()\n                            if (!attr2.contains(Fachattribute.sp\u00e4tbeginnend)) {\n                                attr2.add(Fachattribute.sp\u00e4tbeginnend)\n                            }\n                            fach.attribute = attr2.toList()\n                        }\n                        if (fach.attribute.contains(Fachattribute.GeGe)) {\n                            stundenbelegungAlternativ = mutableListOf<Int>(2, 0, 2, 0) // falls Geschichte LF\n                        }\n                        if (fach.attribute.contains(Fachattribute.Seminarfach)) {\n                            stundenbelegung = mutableListOf(3, 3, 0, 0)\n                        }\n\n                        if (art == Kursart.WF) {\n                            stundenbelegungAlternativ = mutableListOf<Int>(2, 2, 0, 0) // falls Geschichte LF\n                        }\n\n                        liste.add(\n                            Belegfach(\n                                fach.name,\n                                art,\n                                fach.aufgabenfeld,\n                                stundenbelegung,\n                                stundenbelegungAlternativ,\n                                false,\n                                fach.attribute.toMutableList(),\n                                fach.id\n                            )\n                        )\n                    }\n                }\n            }\n            liste.forEachIndexed { index, belegfach -> println(\"$index, $belegfach\") }\n            f\u00e4cherauswahl = liste.toList()\n        }\n    }\n}\n\n\nenum class Aufgabenfeld { I, II, III, Sport, Seminarfach }\n\nenum class Fachattribute { Naturwissenschaft, NawiFe, Deutsch, Fremdsprache, Mathematik, kannNawiErsetzen, Seminarfach, GeGe, Geschichte, MuKu, m\u00fcndlichePr\u00fcfung, sp\u00e4tbeginnend, Orchidee }\n\n\nval anrechnungspflichtigeKurse = listOf<Fachattribute>(\n    Fachattribute.NawiFe,\n    Fachattribute.Mathematik,\n    Fachattribute.Deutsch,\n    Fachattribute.Geschichte,\n    Fachattribute.GeGe,\n    Fachattribute.MuKu\n)\n\ndata class Fach(\n    val name: String,\n    val aufgabenfeld: Aufgabenfeld,\n    val stunden: List<Int>,\n    var attribute: List<Fachattribute>,\n    val id: Int,\n    val pflicht:Boolean\n)\n\n\n\n\n\n\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) count++\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [LinkedHashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\n\npackage kotlin.text\n\nimport kotlin.*\nimport kotlin.comparisons.*\nimport kotlin.internal.contracts.*\n\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex ->\n        indexOfAny(delimiters, startIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex -> findAnyOf(delimitersList, startIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package sample\r\n\r\n/**\r\n * Wandelt einen String, der nur aus 0 und 1 besteht in eine Liste von Strings um, wobei die einzelnen Elemente die L\u00e4nge number haben\r\n */\r\nfun String.cut(number:Int):List<String>{\r\n    val l\u00e4nge=this.length\r\n    var eingabeString=\"0\".repeat((number-l\u00e4nge%number))+this // auf L\u00e4nge durch number teilbar normieren\r\n    var _liste= mutableListOf<String>()\r\n\r\n    for (i in 0..l\u00e4nge/number){\r\n        _liste.add(eingabeString.substring(0..number-1))\r\n        eingabeString=eingabeString.removeRange(0..number-1)\r\n    }\r\n    return _liste\r\n}\r\n\r\nobject Kodierung {\r\n\r\n     fun binarystring2Int(bs:String):Int{\r\n        var zahl=0\r\n        var dummy=bs\r\n        var multiplikator=1\r\n        while (dummy.length>0){\r\n\r\n            zahl+=multiplikator*(if (dummy.last().equals('1')) 1 else 0)\r\n\r\n            dummy=dummy.dropLast(1)\r\n            multiplikator*=2\r\n        }\r\n        return zahl\r\n    }\r\n\r\n    private val bs=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz_-+;\".toList()\r\n\r\n    /**\r\n     * Wandelt einen String, der nur aus 0 und 1 besteht in eine Abfolge von Buchstaben um (\u00e4hnlich Base64)\r\n     */\r\n    fun binarystring2Characterstring(input:String):String{\r\n        val werte=input.cut(6)\r\n        // jetzt Buchstaben zuweisen\r\n        var ergebnis=\"\"\r\n        for (w in werte){\r\n            ergebnis+=bs[binarystring2Int(w)]\r\n        }\r\n        return ergebnis\r\n    }\r\n\r\n    /**\r\n     * Wandelt einen String aus Buchstaben in eine Abfolge von 0 und 1 um, Gegenst\u00fcck zu binarystring2Characterstring\r\n     */\r\n    fun characterstring2Binarystring(input:String):String{\r\n        var ergebnis=\"\"\r\n        input.toList().forEach {\r\n            val wert=bs.indexOf(it).toString(2)\r\n            ergebnis+=\"0\".repeat((6-(wert.length)))+wert\r\n\r\n        }\r\n        return ergebnis.dropWhile { it.equals('0') }\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAt(index: Int): Char {\n    return get(index)\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length)))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each character of the original char sequence.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the desired action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\npublic fun CharSequence.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\npublic fun CharSequence.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val result = ArrayList<R>((thisSize + step - 1) / step)\n    var index = 0\n    while (index < thisSize) {\n        val end = index + size\n        val coercedEnd = if (end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index -> transform(subSequence(index, (index + size).coerceAtMost(length))) }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    return String(chars.copyOfRange(offset, offset + length))\n}\n\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@Deprecated(\"Use length property instead.\", ReplaceWith(\"length\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline val CharSequence.size: Int get() = length\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n","package sample\n\nimport kotlinx.html.dom.*\nimport kotlinx.html.*\nimport kotlinx.html.js.*\nimport kotlin.browser.document\nimport kotlin.browser.window\nimport jquery.*\nimport org.w3c.dom.*\nimport org.w3c.dom.events.EventListener\nimport kotlin.dom.addClass\nimport kotlin.dom.removeClass\n\n\nactual class Sample {\n\n    actual fun checkMe(): Int {\n        window.addEventListener(\"hashchange\", {\n                event ->\n            run {\n                val parameterSet = Variablen.getParameterSet(window.location.hash)\n\n                if (parameterSet.containsKey(\"id\") && !parameterSet.getValue(\"id\").equals(Variablen.status)) {\n                    val aktuelleBelegung = Belegung.getBelegungsobjekt()\n                    aktuelleBelegung.deserialisiere(parameterSet.getValue(\"id\"))\n                    Variablen.status = parameterSet.getValue(\"id\")\n                    erstelleRaster(aktuelleBelegung)\n                    visualisiereBelegung(aktuelleBelegung)\n                    eventsAnh\u00e4ngen(aktuelleBelegung)\n\n                } else {\n                    println(\"Status unver\u00e4ndert\")\n                }\n            }\n        })\n\n        var aktuelleBelegung = Belegung.getBelegungsobjekt()\n        val parameterSet = Variablen.getParameterSet(window.location.hash)\n\n        if (parameterSet.containsKey(\"ansicht\")) {\n            if (parameterSet.getValue(\"ansicht\").equals(\"start\")) {\n                erstelleAuswahl()\n            }\n        } else {\n            if (parameterSet.containsKey(\"ex\")){\n                val wert=parameterSet.getValue(\"ex\")\n                Variablen.excluded=wert\n                if (!wert.equals(\"\")){\n                    println(\"\")\n                    Variablen.excludedList=Kodierung.characterstring2Binarystring(wert).cut(6).map{Kodierung.binarystring2Int(it)}.toMutableList()\n                    println(\"Ausgeschlossene F\u00e4cher: ${Variablen.excludedList}\")\n                }\n\n            }\n        if (parameterSet.containsKey(\"id\") || parameterSet.isEmpty()) {\n\n            if (parameterSet.containsKey((\"id\"))) {\n                Belegung.getBelegungsobjekt().deserialisiere(parameterSet.getValue(\"id\"))\n            }\n\n            Variablen.status = \"${aktuelleBelegung.serialisiere()}\"\n\n            erstelleRaster(aktuelleBelegung)\n            visualisiereBelegung(aktuelleBelegung)\n            eventsAnh\u00e4ngen(aktuelleBelegung)\n        }\n            Variablen.setzeHash()\n        }\n\n\n\n        return 42\n    }\n}\n\n\nactual object Variablen {\n    enum class Ansichten {\n        START, WAHL\n    }\n\n    fun setzeHash(){\n        window.location.hash=\"#id=$status;ex=$excluded\"\n    }\n\n    public var status = \"\"\n    public var excluded=\"\"\n    actual var excludedList= mutableListOf<Int>()\n    var ansicht: Ansichten = Ansichten.WAHL\n\n    fun getParameterSet(input: String): HashMap<String, String> {\n        var hm = hashMapOf<String, String>()\n        val parameter = input.substring(1).split(\";\")\n        for (p in parameter) {\n            val teile = p.split(\"=\")\n            if (teile.size == 2) {\n                hm.put(teile[0], teile[1])\n            }\n        }\n        println(\"ParameterSet: $hm\")\n        return hm\n    }\n\n}\n\nfun erstelleAuswahl() {\n    val myDiv = document.create.div(\"panel\") {\n        h2{\n            +\"Einstellungen\"\n        }\n        +\"Bitte die F\u00e4cher abw\u00e4hlen, die den Sch\u00fclerinnen und Sch\u00fclern bei der Auswahl an ihrer Schule \"\n        span {\n            +\"nicht\"\n            classes = setOf<String>(\"rot\")\n        }\n        +\" angezeigt werden sollen.\"\n        br\n        +\"Danach auf OK dr\u00fccken.\"\n        br\n        +\"Daraufhin werden nur noch die \u00fcbrigen F\u00e4cher inklusive der Pflichtf\u00e4cher in der Kurswahl angezeigt und der Link in der Adresszeile des Browsers kann an die Sch\u00fclerinnen und Sch\u00fcler weitergegeben werden. Somit sehen die Sch\u00fclerinnen und Sch\u00fcler beim Aufruf dieses Links nur noch die verbliebenen F\u00e4cher dieser Liste und die Pflichtf\u00e4cher.\"\n\n        val f\u00e4cher = Belegung.holeF\u00e4cher()\n        ul {\n            for (f in f\u00e4cher) {\n                val klassen = mutableSetOf<String>()\n                if (f.pflicht == false) {\n                    checkBoxInput {\n                        checked = true\n                        id = \"fach_\" + f.id\n                        klassen.add(\"checkbox\")\n                        classes = klassen\n                    }\n                    +f.name\n                    br\n                }\n            }\n        }\n        button {\n            text(\"OK\")\n            onClickFunction = {\n                println(\"Knopf gedr\u00fcckt\")\n                val checkboxes = document.getElementsByClassName(\"checkbox\")\n                val exclude = mutableListOf<Int>()\n                for (i in 0 until checkboxes.length) {\n                    val aktuelleCB = checkboxes[i] as HTMLInputElement\n                    if (!aktuelleCB?.checked ?: false)\n                        exclude.add(aktuelleCB.id.split(\"_\").last().toInt())\n                }\n                var excludedString=\"\"\n                for (e in exclude){\n                    var wert= e.toString(2)\n                    excludedString+=\"0\".repeat(6-wert.length)+wert\n                }\n                val wert=Kodierung.binarystring2Characterstring(excludedString)\n                Variablen.excludedList=exclude\n                Variablen.excluded=wert\n\n                Variablen.setzeHash()\n                val aktuelleBelegung=Belegung.getBelegungsobjekt()\n                erstelleRaster(aktuelleBelegung)\n                visualisiereBelegung(aktuelleBelegung)\n                eventsAnh\u00e4ngen(aktuelleBelegung)\n                Variablen.status = aktuelleBelegung.serialisiere()\n                Variablen.setzeHash()\n            }\n        }\n    }\n    val con = document.getElementById(\"container\")\n    con!!.innerHTML = \"\"\n\n    document.getElementById(\"container\")!!.appendChild(myDiv)\n    println(\"Auswahlansicht\")\n}\n\nfun erstelleRaster(aktuelleBelegung: Belegung) {\n    aktuelleBelegung.action(Belegung.Companion.Aktion.CHECK)\n    val darstellung = aktuelleBelegung.holeDarstellung()\n    val f\u00e4cherauswahl = aktuelleBelegung.getF\u00e4cher().groupBy { it.aufgabenfeld }\n    val myDiv = document.create.div(\"panel\") {\n\n        table {\n\n            for (zeile in darstellung) {\n                if (zeile is Belegung.\u00dcberschrift) {\n                    tr {\n                        td {\n                            classes = setOf(\"fett\")\n                            +zeile.text\n                        }\n                        for (i in 0..5) {\n                            td {} //Leere Felder\n                        }\n                    }\n                } else if (zeile is Belegung.Summe) {\n                    tr {\n                        td {\n                            classes = setOf(\"fett\")\n                            +\"Wochenstunden\"\n                        }\n                        for (i in 0..2) {\n                            td {} //Leere Felder\n                        }\n                        for (i in 0..3) {\n                            td {\n                                +zeile.stunden[i].toString()\n                                classes = setOf(\"fett\")\n                            }\n                        }\n                    }\n                } else if (zeile is Belegung.ZeileDarstellung) {\n                    tr {\n                        td {\n                            +zeile.name\n                        }\n                        td {\n                            var klassen = mutableSetOf<String>()\n                            if (zeile.klickbar.contains(Belegung.Companion.Kursart.LF)) {\n                                +\"LF\"\n                                klassen.add(\"klickbar\")\n                                id = zeile.fachnameOriginal + \"_LF\"\n                            }\n                            if (zeile.gew\u00e4hlt == Belegung.Companion.Kursart.LF) {\n                                klassen.add(\"belegt_LF\")\n                            }\n\n                            classes = klassen\n                        }\n                        td {\n                            var klassen = mutableSetOf<String>()\n                            if (zeile.klickbar.contains(Belegung.Companion.Kursart.BF)) {\n                                +\"BF\"\n                                klassen.add(\"klickbar\")\n                                id = zeile.fachnameOriginal + \"_BF\"\n\n                                if (zeile.gew\u00e4hlt == Belegung.Companion.Kursart.BF) {\n                                    klassen.add(\"belegt_BF\")\n                                }\n                            } else if (zeile.klickbar.contains(Belegung.Companion.Kursart.WF)) {\n                                +\"WF\"\n                                klassen.add(\"klickbar\")\n                                id = zeile.fachnameOriginal + \"_WF\"\n\n                                if (zeile.gew\u00e4hlt == Belegung.Companion.Kursart.WF) {\n                                    klassen.add(\"belegt_WF\")\n                                }\n                            }\n                            classes = klassen\n                        }\n                        td {\n                            var klassen = mutableSetOf<String>()\n                            if (zeile.m\u00fcndlichKlickbar) {\n\n                                klassen.add(\"klickbar\")\n                                val gew\u00e4hlt = zeile.gew\u00e4hlt ?: \"\"\n                                if (gew\u00e4hlt is Belegung.Companion.Kursart) {\n                                    if (gew\u00e4hlt == Belegung.Companion.Kursart.BF) {\n                                        id = zeile.fachnameOriginal + \"_mBF\"\n                                    } else if (gew\u00e4hlt == Belegung.Companion.Kursart.WF) {\n                                        id = zeile.fachnameOriginal + \"_mWF\"\n                                    }\n                                }\n\n                            } else {\n\n                            }\n                            classes = klassen\n                        }\n\n                        val gew\u00e4hlt = zeile.gew\u00e4hlt ?: \"\"\n\n                        for (i in 0..3) {\n                            td {\n                                var klassen = mutableSetOf<String>()\n                                if (gew\u00e4hlt is Belegung.Companion.Kursart) {\n                                    if (zeile.stunden[i] != 0) {\n                                        +zeile.stunden[i].toString()\n\n                                        //println(\"Stunden $i ${zeile.stunden[i]}\")\n                                        if (zeile.stundenAlternativVorhanden == true) {\n                                            klassen.add(\"klickbar\")\n                                            klassen.add(\"stunden\")\n\n                                            if (gew\u00e4hlt == Belegung.Companion.Kursart.BF) {\n                                                id = zeile.name + \"_stundenBF\"\n                                            } else if (gew\u00e4hlt == Belegung.Companion.Kursart.WF) {\n                                                id = zeile.name + \"_stundenWF\"\n                                            }\n                                        }\n                                    } else {\n                                        +\" \"\n                                    }\n                                } else {\n                                    +\" \"\n                                }\n                                if (zeile.anrechnungspflichtig[i]==1){\n                                    klassen.add(\"fett\")\n                                    klassen.add(\"blau\")\n                                }\n                                classes = klassen\n                            }\n\n                        }\n\n                    }\n                }\n            }\n        }\n        div {\n            val meldungen = aktuelleBelegung.holeFehler()\n            ul {\n                meldungen.forEach {\n                    li {\n\n                        span {\n                            if (it.kommentarart == Belegung.Kommentarart.SCHLECHT) {\n                                classes = setOf(\"rot\")\n\n                            } else if (it.kommentarart == Belegung.Kommentarart.GUT) {\n                                classes = setOf(\"gr\u00fcn\")\n\n                            } else {\n                                classes = setOf()\n                            }\n                            +it.text\n                        }\n\n                    }\n                }\n            }\n        }\n        div {\n            if (Belegung.holeKurswahlKorrekt()){\n                +\"Kurswahl g\u00fcltig! Anrechnungspflichtige Kurse sind in der Kurswahl blau und fett dargestellt.\"\n                br\n                +\"Richtigkeit der Kurswahl ohne Gew\u00e4hr: bitte unbedingt zusammen mit dem Oberstufenberater \u00fcberpr\u00fcfen! \"\n\n                classes=setOf(\"gr\u00fcnText\",\"fett\")\n            } else {\n                +\"Kurswahl ung\u00fcltig!\"\n                classes=setOf(\"rotText\",\"fett\")\n            }\n\n        }\n    }\n\n    val con = document.getElementById(\"container\")\n    con!!.innerHTML = \"\"\n\n    document.getElementById(\"container\")!!.appendChild(myDiv)\n\n\n\n\n    //document.getElementById(\"container\")!!.append {\n    //}\n}\n\nfun eventsAnh\u00e4ngen(aktuelleBelegung: Belegung) {\n    val elemente = document.getElementsByClassName(\"klickbar\")\n    for (i in 0..elemente.length) {\n        if (elemente[i] != null) {\n            elemente[i]!!.addEventListener(\"click\",\n                { event ->\n                    val id = elemente[i]?.id ?: \"\"\n                    val typEvent = id.split(\"_\")\n                    var refresh = false\n                    if (typEvent.size == 2) {\n                        if (typEvent[1].startsWith(\"m\")) {\n                            aktuelleBelegung.action(\n                                Belegung.Companion.Aktion.TOGGLEM\u00dcNDLICH,\n                                typEvent[0],\n                                if (typEvent[1].substring(1) == \"BF\") Belegung.Companion.Kursart.BF else Belegung.Companion.Kursart.WF\n                            )\n                            refresh = true\n                        } else if (typEvent[1] == \"LF\") {\n                            aktuelleBelegung.action(\n                                Belegung.Companion.Aktion.TOGGLE,\n                                typEvent[0],\n                                Belegung.Companion.Kursart.LF\n                            )\n                            refresh = true\n                        } else if (typEvent[1] == \"BF\") {\n                            aktuelleBelegung.action(\n                                Belegung.Companion.Aktion.TOGGLE,\n                                typEvent[0],\n                                Belegung.Companion.Kursart.BF\n                            )\n                            refresh = true\n                        } else if (typEvent[1] == \"WF\") {\n                            aktuelleBelegung.action(\n                                Belegung.Companion.Aktion.TOGGLE,\n                                typEvent[0],\n                                Belegung.Companion.Kursart.WF\n                            )\n                            refresh = true\n                        } else if (typEvent[1].startsWith(\"stunden\")) {\n                            aktuelleBelegung.action(\n                                Belegung.Companion.Aktion.TOGGLESTUNDEN,\n                                typEvent[0],\n                                if (typEvent[1].substring(7) == \"BF\") Belegung.Companion.Kursart.BF else Belegung.Companion.Kursart.WF\n                            )\n                            refresh = true\n                        }\n                    }\n                    if (refresh == true) {\n                        erstelleRaster(aktuelleBelegung)\n                        visualisiereBelegung(aktuelleBelegung)\n                        eventsAnh\u00e4ngen(aktuelleBelegung)\n                        aktuelleBelegung.action(Belegung.Companion.Aktion.CHECK)\n                        Variablen.status=aktuelleBelegung.serialisiere()\n                        Variablen.setzeHash()\n                    }\n                }\n            )\n        }\n    }\n}\n\nfun visualisiereBelegung(aktuelleBelegung: Belegung) {\n    val belegung = Belegung.getBelegungsobjekt().getBelegung()\n    belegung.forEach {\n        val id = it.name + \"_\" + it.typ\n        val id_m\u00fcndlich =\n            it.name + \"_m\" + if (it.typ == Belegung.Companion.Kursart.BF) \"BF\" else if (it.typ == Belegung.Companion.Kursart.WF) \"WF\" else \"\"\n        val typ = it.typ\n        val zelle = document.getElementById(id)\n        if (aktuelleBelegung.getBelegung().filter { it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung) }.count() < 2) {\n            if (it.typ == Belegung.Companion.Kursart.BF || it.typ == Belegung.Companion.Kursart.WF) {\n                document.getElementById(id_m\u00fcndlich)?.addClass(\"klickbar\")\n            }\n        } else {\n            if (it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n                document.getElementById(id_m\u00fcndlich)?.addClass(\"klickbar\")\n\n            }\n        }\n\n        zelle?.let {\n            it.addClass(\"belegt_\" + typ)\n        }\n        if (it.attribute.contains(Fachattribute.m\u00fcndlichePr\u00fcfung)) {\n            document.getElementById(id_m\u00fcndlich)?.innerHTML = \"X\"\n\n        } else {\n            document.getElementById(id_m\u00fcndlich)?.innerHTML = \"&nbsp;&nbsp;\"\n        }\n    }\n}\n\nactual object Platform {\n    actual val name: String = \"JS\"\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.dom\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Document](https://developer.mozilla.org/en/docs/Web/API/Document) to Kotlin\n */\npublic external open class Document : Node, GlobalEventHandlers, DocumentAndElementEventHandlers, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GeometryUtils {\n    open val fullscreenEnabled: Boolean\n    open val fullscreen: Boolean\n    var onfullscreenchange: ((Event) -> dynamic)?\n    var onfullscreenerror: ((Event) -> dynamic)?\n    open val rootElement: SVGSVGElement?\n    var title: String\n    open val referrer: String\n    var domain: String\n    open val activeElement: Element?\n    open val location: Location?\n    var cookie: String\n    open val lastModified: String\n    open val readyState: DocumentReadyState\n    var dir: String\n    var body: HTMLElement?\n    open val head: HTMLHeadElement?\n    open val images: HTMLCollection\n    open val embeds: HTMLCollection\n    open val plugins: HTMLCollection\n    open val links: HTMLCollection\n    open val forms: HTMLCollection\n    open val scripts: HTMLCollection\n    open val currentScript: HTMLOrSVGScriptElement?\n    open val defaultView: Window?\n    var designMode: String\n    var onreadystatechange: ((Event) -> dynamic)?\n    var fgColor: String\n    var linkColor: String\n    var vlinkColor: String\n    var alinkColor: String\n    var bgColor: String\n    open val anchors: HTMLCollection\n    open val applets: HTMLCollection\n    open val all: HTMLAllCollection\n    open val implementation: DOMImplementation\n    open val URL: String\n    open val documentURI: String\n    open val origin: String\n    open val compatMode: String\n    open val characterSet: String\n    open val charset: String\n    open val inputEncoding: String\n    open val contentType: String\n    open val doctype: DocumentType?\n    open val documentElement: Element?\n    open val scrollingElement: Element?\n    open val styleSheets: StyleSheetList\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((Event) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((Event) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((Event) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((Event) -> dynamic)?\n    override var ondrag: ((Event) -> dynamic)?\n    override var ondragend: ((Event) -> dynamic)?\n    override var ondragenter: ((Event) -> dynamic)?\n    override var ondragexit: ((Event) -> dynamic)?\n    override var ondragleave: ((Event) -> dynamic)?\n    override var ondragover: ((Event) -> dynamic)?\n    override var ondragstart: ((Event) -> dynamic)?\n    override var ondrop: ((Event) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((Event) -> dynamic)?\n    override var oninput: ((Event) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((Event) -> dynamic)?\n    override var onkeypress: ((Event) -> dynamic)?\n    override var onkeyup: ((Event) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((Event) -> dynamic)?\n    override var onmousedown: ((Event) -> dynamic)?\n    override var onmouseenter: ((Event) -> dynamic)?\n    override var onmouseleave: ((Event) -> dynamic)?\n    override var onmousemove: ((Event) -> dynamic)?\n    override var onmouseout: ((Event) -> dynamic)?\n    override var onmouseover: ((Event) -> dynamic)?\n    override var onmouseup: ((Event) -> dynamic)?\n    override var onwheel: ((Event) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((Event) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((Event) -> dynamic)?\n    override var oncut: ((Event) -> dynamic)?\n    override var onpaste: ((Event) -> dynamic)?\n    override val fullscreenElement: Element?\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    fun exitFullscreen(): Promise<Unit>\n    fun getElementsByName(elementName: String): NodeList\n    fun open(type: String = definedExternally, replace: String = definedExternally): Document\n    fun open(url: String, name: String, features: String): Window\n    fun close(): Unit\n    fun write(vararg text: String): Unit\n    fun writeln(vararg text: String): Unit\n    fun hasFocus(): Boolean\n    fun execCommand(commandId: String, showUI: Boolean = definedExternally, value: String = definedExternally): Boolean\n    fun queryCommandEnabled(commandId: String): Boolean\n    fun queryCommandIndeterm(commandId: String): Boolean\n    fun queryCommandState(commandId: String): Boolean\n    fun queryCommandSupported(commandId: String): Boolean\n    fun queryCommandValue(commandId: String): String\n    fun clear(): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun createElement(localName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createDocumentFragment(): DocumentFragment\n    fun createTextNode(data: String): Text\n    fun createCDATASection(data: String): CDATASection\n    fun createComment(data: String): Comment\n    fun createProcessingInstruction(target: String, data: String): ProcessingInstruction\n    fun importNode(node: Node, deep: Boolean = definedExternally): Node\n    fun adoptNode(node: Node): Node\n    fun createAttribute(localName: String): Attr\n    fun createAttributeNS(namespace: String?, qualifiedName: String): Attr\n    fun createEvent(interface_: String): Event\n    fun createRange(): Range\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): NodeIterator\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): NodeIterator\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): TreeWalker\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): TreeWalker\n    fun elementFromPoint(x: Double, y: Double): Element?\n    fun elementsFromPoint(x: Double, y: Double): Array<Element>\n    fun caretPositionFromPoint(x: Double, y: Double): CaretPosition?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n@kotlin.internal.InlineOnly inline operator fun Document.get(name: String): dynamic = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Window](https://developer.mozilla.org/en/docs/Web/API/Window) to Kotlin\n */\npublic external abstract class Window : EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, WindowSessionStorage, WindowLocalStorage, GlobalPerformance, UnionMessagePortOrWindow {\n    override val performance: Performance\n    open val window: Window\n    open val self: Window\n    open val document: Document\n    open var name: String\n    open val location: Location\n    open val history: History\n    open val customElements: CustomElementRegistry\n    open val locationbar: BarProp\n    open val menubar: BarProp\n    open val personalbar: BarProp\n    open val scrollbars: BarProp\n    open val statusbar: BarProp\n    open val toolbar: BarProp\n    open var status: String\n    open val closed: Boolean\n    open val frames: Window\n    open val length: Int\n    open val top: Window\n    open var opener: Any?\n    open val parent: Window\n    open val frameElement: Element?\n    open val navigator: Navigator\n    open val applicationCache: ApplicationCache\n    open val external: External\n    open val screen: Screen\n    open val innerWidth: Int\n    open val innerHeight: Int\n    open val scrollX: Double\n    open val pageXOffset: Double\n    open val scrollY: Double\n    open val pageYOffset: Double\n    open val screenX: Int\n    open val screenY: Int\n    open val outerWidth: Int\n    open val outerHeight: Int\n    open val devicePixelRatio: Double\n    fun close(): Unit\n    fun stop(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?\n    fun alert(): Unit\n    fun alert(message: String): Unit\n    fun confirm(message: String = definedExternally): Boolean\n    fun prompt(message: String = definedExternally, default: String = definedExternally): String?\n    fun print(): Unit\n    fun requestAnimationFrame(callback: (Double) -> Unit): Int\n    fun cancelAnimationFrame(handle: Int): Unit\n    fun postMessage(message: Any?, targetOrigin: String, transfer: Array<dynamic> = definedExternally): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun matchMedia(query: String): MediaQueryList\n    fun moveTo(x: Int, y: Int): Unit\n    fun moveBy(x: Int, y: Int): Unit\n    fun resizeTo(x: Int, y: Int): Unit\n    fun resizeBy(x: Int, y: Int): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration\n}\n@kotlin.internal.InlineOnly inline operator fun Window.get(name: String): dynamic = asDynamic()[name]\n\npublic external abstract class HTMLAllCollection {\n    open val length: Int\n//    fun namedItem(name: String): UnionElementOrHTMLCollection?\n    fun item(nameOrIndex: String = definedExternally): UnionElementOrHTMLCollection?\n}\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(index: Int): Element? = asDynamic()[index]\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(name: String): UnionElementOrHTMLCollection? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLFormControlsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLFormControlsCollection) to Kotlin\n */\npublic external abstract class HTMLFormControlsCollection : HTMLCollection {\n//    override fun namedItem(name: String): UnionElementOrRadioNodeList?\n}\n//@kotlin.internal.InlineOnly override inline operator fun HTMLFormControlsCollection.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [RadioNodeList](https://developer.mozilla.org/en/docs/Web/API/RadioNodeList) to Kotlin\n */\npublic external abstract class RadioNodeList : NodeList, UnionElementOrRadioNodeList {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionsCollection) to Kotlin\n */\npublic external abstract class HTMLOptionsCollection : HTMLCollection {\n    override var length: Int\n    open var selectedIndex: Int\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLOptionsCollection.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLElement](https://developer.mozilla.org/en/docs/Web/API/HTMLElement) to Kotlin\n */\npublic external abstract class HTMLElement : Element, ElementCSSInlineStyle, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable {\n    open var title: String\n    open var lang: String\n    open var translate: Boolean\n    open var dir: String\n    open val dataset: DOMStringMap\n    open var hidden: Boolean\n    open var tabIndex: Int\n    open var accessKey: String\n    open val accessKeyLabel: String\n    open var draggable: Boolean\n    open val dropzone: DOMTokenList\n    open var contextMenu: HTMLMenuElement?\n    open var spellcheck: Boolean\n    open var innerText: String\n    open val offsetParent: Element?\n    open val offsetTop: Int\n    open val offsetLeft: Int\n    open val offsetWidth: Int\n    open val offsetHeight: Int\n    fun click(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun forceSpellCheck(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLUnknownElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUnknownElement) to Kotlin\n */\npublic external abstract class HTMLUnknownElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [DOMStringMap](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) to Kotlin\n */\npublic external abstract class DOMStringMap {\n}\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.get(name: String): String? = asDynamic()[name]\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.set(name: String, value: String): Unit { asDynamic()[name] = value; }\n\n/**\n * Exposes the JavaScript [HTMLHtmlElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHtmlElement) to Kotlin\n */\npublic external abstract class HTMLHtmlElement : HTMLElement {\n    open var version: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadElement) to Kotlin\n */\npublic external abstract class HTMLHeadElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLTitleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTitleElement) to Kotlin\n */\npublic external abstract class HTMLTitleElement : HTMLElement {\n    open var text: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBaseElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBaseElement) to Kotlin\n */\npublic external abstract class HTMLBaseElement : HTMLElement {\n    open var href: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLinkElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLinkElement) to Kotlin\n */\npublic external abstract class HTMLLinkElement : HTMLElement, LinkStyle {\n    open var scope: String\n    open var workerType: WorkerType\n    open var href: String\n    open var crossOrigin: String?\n    open var rel: String\n    @JsName(\"as\") open var as_: RequestDestination\n    open val relList: DOMTokenList\n    open var media: String\n    open var nonce: String\n    open var hreflang: String\n    open var type: String\n    open val sizes: DOMTokenList\n    open var referrerPolicy: String\n    open var charset: String\n    open var rev: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLMetaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMetaElement) to Kotlin\n */\npublic external abstract class HTMLMetaElement : HTMLElement {\n    open var name: String\n    open var httpEquiv: String\n    open var content: String\n    open var scheme: String\n}\n\n/**\n * Exposes the JavaScript [HTMLStyleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLStyleElement) to Kotlin\n */\npublic external abstract class HTMLStyleElement : HTMLElement, LinkStyle {\n    open var media: String\n    open var nonce: String\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBodyElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBodyElement) to Kotlin\n */\npublic external abstract class HTMLBodyElement : HTMLElement, WindowEventHandlers {\n    open var text: String\n    open var link: String\n    open var vLink: String\n    open var aLink: String\n    open var bgColor: String\n    open var background: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadingElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadingElement) to Kotlin\n */\npublic external abstract class HTMLHeadingElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLParagraphElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParagraphElement) to Kotlin\n */\npublic external abstract class HTMLParagraphElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHRElement) to Kotlin\n */\npublic external abstract class HTMLHRElement : HTMLElement {\n    open var align: String\n    open var color: String\n    open var noShade: Boolean\n    open var size: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPreElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPreElement) to Kotlin\n */\npublic external abstract class HTMLPreElement : HTMLElement {\n    open var width: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLQuoteElement](https://developer.mozilla.org/en/docs/Web/API/HTMLQuoteElement) to Kotlin\n */\npublic external abstract class HTMLQuoteElement : HTMLElement {\n    open var cite: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOListElement) to Kotlin\n */\npublic external abstract class HTMLOListElement : HTMLElement {\n    open var reversed: Boolean\n    open var start: Int\n    open var type: String\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLUListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUListElement) to Kotlin\n */\npublic external abstract class HTMLUListElement : HTMLElement {\n    open var compact: Boolean\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLIElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLIElement) to Kotlin\n */\npublic external abstract class HTMLLIElement : HTMLElement {\n    open var value: Int\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDListElement) to Kotlin\n */\npublic external abstract class HTMLDListElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDivElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDivElement) to Kotlin\n */\npublic external abstract class HTMLDivElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLAnchorElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement) to Kotlin\n */\npublic external abstract class HTMLAnchorElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var hreflang: String\n    open var type: String\n    open var text: String\n    open var referrerPolicy: String\n    open var coords: String\n    open var charset: String\n    open var name: String\n    open var rev: String\n    open var shape: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDataElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataElement) to Kotlin\n */\npublic external abstract class HTMLDataElement : HTMLElement {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTimeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTimeElement) to Kotlin\n */\npublic external abstract class HTMLTimeElement : HTMLElement {\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLSpanElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSpanElement) to Kotlin\n */\npublic external abstract class HTMLSpanElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLBRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBRElement) to Kotlin\n */\npublic external abstract class HTMLBRElement : HTMLElement {\n    open var clear: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHyperlinkElementUtils](https://developer.mozilla.org/en/docs/Web/API/HTMLHyperlinkElementUtils) to Kotlin\n */\npublic external interface HTMLHyperlinkElementUtils {\n    var href: String\n    val origin: String\n    var protocol: String\n    var username: String\n    var password: String\n    var host: String\n    var hostname: String\n    var port: String\n    var pathname: String\n    var search: String\n    var hash: String\n}\n\n/**\n * Exposes the JavaScript [HTMLModElement](https://developer.mozilla.org/en/docs/Web/API/HTMLModElement) to Kotlin\n */\npublic external abstract class HTMLModElement : HTMLElement {\n    open var cite: String\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPictureElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPictureElement) to Kotlin\n */\npublic external abstract class HTMLPictureElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLSourceElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSourceElement) to Kotlin\n */\npublic external abstract class HTMLSourceElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var srcset: String\n    open var sizes: String\n    open var media: String\n}\n\n/**\n * Exposes the JavaScript [HTMLImageElement](https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement) to Kotlin\n */\npublic external abstract class HTMLImageElement : HTMLElement, TexImageSource, HTMLOrSVGImageElement {\n    open var alt: String\n    open var src: String\n    open var srcset: String\n    open var sizes: String\n    open var crossOrigin: String?\n    open var useMap: String\n    open var isMap: Boolean\n    open var width: Int\n    open var height: Int\n    open val naturalWidth: Int\n    open val naturalHeight: Int\n    open val complete: Boolean\n    open val currentSrc: String\n    open var referrerPolicy: String\n    open var name: String\n    open var lowsrc: String\n    open var align: String\n    open var hspace: Int\n    open var vspace: Int\n    open var longDesc: String\n    open var border: String\n    open val x: Int\n    open val y: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLIFrameElement](https://developer.mozilla.org/en/docs/Web/API/HTMLIFrameElement) to Kotlin\n */\npublic external abstract class HTMLIFrameElement : HTMLElement {\n    open var src: String\n    open var srcdoc: String\n    open var name: String\n    open val sandbox: DOMTokenList\n    open var allowFullscreen: Boolean\n    open var allowUserMedia: Boolean\n    open var width: String\n    open var height: String\n    open var referrerPolicy: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var align: String\n    open var scrolling: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var marginHeight: String\n    open var marginWidth: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLEmbedElement](https://developer.mozilla.org/en/docs/Web/API/HTMLEmbedElement) to Kotlin\n */\npublic external abstract class HTMLEmbedElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var width: String\n    open var height: String\n    open var align: String\n    open var name: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLObjectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLObjectElement) to Kotlin\n */\npublic external abstract class HTMLObjectElement : HTMLElement {\n    open var data: String\n    open var type: String\n    open var typeMustMatch: Boolean\n    open var name: String\n    open var useMap: String\n    open val form: HTMLFormElement?\n    open var width: String\n    open var height: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open var align: String\n    open var archive: String\n    open var code: String\n    open var declare: Boolean\n    open var hspace: Int\n    open var standby: String\n    open var vspace: Int\n    open var codeBase: String\n    open var codeType: String\n    open var border: String\n    fun getSVGDocument(): Document?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLParamElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParamElement) to Kotlin\n */\npublic external abstract class HTMLParamElement : HTMLElement {\n    open var name: String\n    open var value: String\n    open var type: String\n    open var valueType: String\n}\n\n/**\n * Exposes the JavaScript [HTMLVideoElement](https://developer.mozilla.org/en/docs/Web/API/HTMLVideoElement) to Kotlin\n */\npublic external abstract class HTMLVideoElement : HTMLMediaElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    open val videoWidth: Int\n    open val videoHeight: Int\n    open var poster: String\n    open var playsInline: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLAudioElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement) to Kotlin\n */\npublic external abstract class HTMLAudioElement : HTMLMediaElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLTrackElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTrackElement) to Kotlin\n */\npublic external abstract class HTMLTrackElement : HTMLElement {\n    open var kind: String\n    open var src: String\n    open var srclang: String\n    open var label: String\n    open var default: Boolean\n    open val readyState: Short\n    open val track: TextTrack\n\n    companion object {\n        val NONE: Short\n        val LOADING: Short\n        val LOADED: Short\n        val ERROR: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMediaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMediaElement) to Kotlin\n */\npublic external abstract class HTMLMediaElement : HTMLElement {\n    open val error: MediaError?\n    open var src: String\n    open var srcObject: dynamic\n    open val currentSrc: String\n    open var crossOrigin: String?\n    open val networkState: Short\n    open var preload: String\n    open val buffered: TimeRanges\n    open val readyState: Short\n    open val seeking: Boolean\n    open var currentTime: Double\n    open val duration: Double\n    open val paused: Boolean\n    open var defaultPlaybackRate: Double\n    open var playbackRate: Double\n    open val played: TimeRanges\n    open val seekable: TimeRanges\n    open val ended: Boolean\n    open var autoplay: Boolean\n    open var loop: Boolean\n    open var controls: Boolean\n    open var volume: Double\n    open var muted: Boolean\n    open var defaultMuted: Boolean\n    open val audioTracks: AudioTrackList\n    open val videoTracks: VideoTrackList\n    open val textTracks: TextTrackList\n    fun load(): Unit\n    fun canPlayType(type: String): CanPlayTypeResult\n    fun fastSeek(time: Double): Unit\n    fun getStartDate(): dynamic\n    fun play(): Promise<Unit>\n    fun pause(): Unit\n    fun addTextTrack(kind: TextTrackKind, label: String = definedExternally, language: String = definedExternally): TextTrack\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [MediaError](https://developer.mozilla.org/en/docs/Web/API/MediaError) to Kotlin\n */\npublic external abstract class MediaError {\n    open val code: Short\n\n    companion object {\n        val MEDIA_ERR_ABORTED: Short\n        val MEDIA_ERR_NETWORK: Short\n        val MEDIA_ERR_DECODE: Short\n        val MEDIA_ERR_SRC_NOT_SUPPORTED: Short\n    }\n}\n\npublic external abstract class AudioTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): AudioTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun AudioTrackList.get(index: Int): AudioTrack? = asDynamic()[index]\n\npublic external abstract class AudioTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var enabled: Boolean\n}\n\npublic external abstract class VideoTrackList : EventTarget {\n    open val length: Int\n    open val selectedIndex: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): VideoTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun VideoTrackList.get(index: Int): VideoTrack? = asDynamic()[index]\n\npublic external abstract class VideoTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var selected: Boolean\n}\n\npublic external abstract class TextTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): TextTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackList.get(index: Int): TextTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrack](https://developer.mozilla.org/en/docs/Web/API/TextTrack) to Kotlin\n */\npublic external abstract class TextTrack : EventTarget, UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val kind: TextTrackKind\n    open val label: String\n    open val language: String\n    open val id: String\n    open val inBandMetadataTrackDispatchType: String\n    open var mode: TextTrackMode\n    open val cues: TextTrackCueList?\n    open val activeCues: TextTrackCueList?\n    open var oncuechange: ((Event) -> dynamic)?\n    fun addCue(cue: TextTrackCue): Unit\n    fun removeCue(cue: TextTrackCue): Unit\n}\n\npublic external abstract class TextTrackCueList {\n    open val length: Int\n    fun getCueById(id: String): TextTrackCue?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackCueList.get(index: Int): TextTrackCue? = asDynamic()[index]\n\npublic external abstract class TextTrackCue : EventTarget {\n    open val track: TextTrack?\n    open var id: String\n    open var startTime: Double\n    open var endTime: Double\n    open var pauseOnExit: Boolean\n    open var onenter: ((Event) -> dynamic)?\n    open var onexit: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin\n */\npublic external abstract class TimeRanges {\n    open val length: Int\n    fun start(index: Int): Double\n    fun end(index: Int): Double\n}\n\npublic external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event {\n    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?\n}\n\npublic external interface TrackEventInit : EventInit {\n    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit {\n    val o = js(\"({})\")\n\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin\n */\npublic external abstract class HTMLMapElement : HTMLElement {\n    open var name: String\n    open val areas: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAreaElement) to Kotlin\n */\npublic external abstract class HTMLAreaElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var alt: String\n    open var coords: String\n    open var shape: String\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var referrerPolicy: String\n    open var noHref: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLTableElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableElement) to Kotlin\n */\npublic external abstract class HTMLTableElement : HTMLElement {\n    open var caption: HTMLTableCaptionElement?\n    open var tHead: HTMLTableSectionElement?\n    open var tFoot: HTMLTableSectionElement?\n    open val tBodies: HTMLCollection\n    open val rows: HTMLCollection\n    open var align: String\n    open var border: String\n    open var frame: String\n    open var rules: String\n    open var summary: String\n    open var width: String\n    open var bgColor: String\n    open var cellPadding: String\n    open var cellSpacing: String\n    fun createCaption(): HTMLTableCaptionElement\n    fun deleteCaption(): Unit\n    fun createTHead(): HTMLTableSectionElement\n    fun deleteTHead(): Unit\n    fun createTFoot(): HTMLTableSectionElement\n    fun deleteTFoot(): Unit\n    fun createTBody(): HTMLTableSectionElement\n    fun insertRow(index: Int = definedExternally): HTMLTableRowElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCaptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCaptionElement) to Kotlin\n */\npublic external abstract class HTMLTableCaptionElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableColElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableColElement) to Kotlin\n */\npublic external abstract class HTMLTableColElement : HTMLElement {\n    open var span: Int\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableSectionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableSectionElement) to Kotlin\n */\npublic external abstract class HTMLTableSectionElement : HTMLElement {\n    open val rows: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    fun insertRow(index: Int = definedExternally): HTMLElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableRowElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableRowElement) to Kotlin\n */\npublic external abstract class HTMLTableRowElement : HTMLElement {\n    open val rowIndex: Int\n    open val sectionRowIndex: Int\n    open val cells: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var bgColor: String\n    fun insertCell(index: Int = definedExternally): HTMLElement\n    fun deleteCell(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCellElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCellElement) to Kotlin\n */\npublic external abstract class HTMLTableCellElement : HTMLElement {\n    open var colSpan: Int\n    open var rowSpan: Int\n    open var headers: String\n    open val cellIndex: Int\n    open var scope: String\n    open var abbr: String\n    open var align: String\n    open var axis: String\n    open var height: String\n    open var width: String\n    open var ch: String\n    open var chOff: String\n    open var noWrap: Boolean\n    open var vAlign: String\n    open var bgColor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLFormElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFormElement) to Kotlin\n */\npublic external abstract class HTMLFormElement : HTMLElement {\n    open var acceptCharset: String\n    open var action: String\n    open var autocomplete: String\n    open var enctype: String\n    open var encoding: String\n    open var method: String\n    open var name: String\n    open var noValidate: Boolean\n    open var target: String\n    open val elements: HTMLFormControlsCollection\n    open val length: Int\n    fun submit(): Unit\n    fun reset(): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLLabelElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLabelElement) to Kotlin\n */\npublic external abstract class HTMLLabelElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var htmlFor: String\n    open val control: HTMLElement?\n}\n\n/**\n * Exposes the JavaScript [HTMLInputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement) to Kotlin\n */\npublic external abstract class HTMLInputElement : HTMLElement {\n    open var accept: String\n    open var alt: String\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var defaultChecked: Boolean\n    open var checked: Boolean\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open val files: FileList?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var height: Int\n    open var indeterminate: Boolean\n    open var inputMode: String\n    open val list: HTMLElement?\n    open var max: String\n    open var maxLength: Int\n    open var min: String\n    open var minLength: Int\n    open var multiple: Boolean\n    open var name: String\n    open var pattern: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var size: Int\n    open var src: String\n    open var step: String\n    open var type: String\n    open var defaultValue: String\n    open var value: String\n    open var valueAsDate: dynamic\n    open var valueAsNumber: Double\n    open var width: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    open var align: String\n    open var useMap: String\n    fun stepUp(n: Int = definedExternally): Unit\n    fun stepDown(n: Int = definedExternally): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLButtonElement](https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement) to Kotlin\n */\npublic external abstract class HTMLButtonElement : HTMLElement {\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var name: String\n    open var type: String\n    open var value: String\n    open var menu: HTMLMenuElement?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLSelectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSelectElement) to Kotlin\n */\npublic external abstract class HTMLSelectElement : HTMLElement, ItemArrayLike<Element> {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var multiple: Boolean\n    open var name: String\n    open var required: Boolean\n    open var size: Int\n    open val type: String\n    open val options: HTMLOptionsCollection\n    override var length: Int\n    open val selectedOptions: HTMLCollection\n    open var selectedIndex: Int\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): HTMLOptionElement?\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLDataListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataListElement) to Kotlin\n */\npublic external abstract class HTMLDataListElement : HTMLElement {\n    open val options: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLOptGroupElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptGroupElement) to Kotlin\n */\npublic external abstract class HTMLOptGroupElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open var label: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionElement) to Kotlin\n */\npublic external abstract class HTMLOptionElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var label: String\n    open var defaultSelected: Boolean\n    open var selected: Boolean\n    open var value: String\n    open var text: String\n    open val index: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLTextAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTextAreaElement) to Kotlin\n */\npublic external abstract class HTMLTextAreaElement : HTMLElement {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var cols: Int\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var inputMode: String\n    open var maxLength: Int\n    open var minLength: Int\n    open var name: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var rows: Int\n    open var wrap: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val textLength: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLKeygenElement](https://developer.mozilla.org/en/docs/Web/API/HTMLKeygenElement) to Kotlin\n */\npublic external abstract class HTMLKeygenElement : HTMLElement {\n    open var autofocus: Boolean\n    open var challenge: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var keytype: String\n    open var name: String\n    open val type: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLOutputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOutputElement) to Kotlin\n */\npublic external abstract class HTMLOutputElement : HTMLElement {\n    open val htmlFor: DOMTokenList\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLProgressElement](https://developer.mozilla.org/en/docs/Web/API/HTMLProgressElement) to Kotlin\n */\npublic external abstract class HTMLProgressElement : HTMLElement {\n    open var value: Double\n    open var max: Double\n    open val position: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLMeterElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMeterElement) to Kotlin\n */\npublic external abstract class HTMLMeterElement : HTMLElement {\n    open var value: Double\n    open var min: Double\n    open var max: Double\n    open var low: Double\n    open var high: Double\n    open var optimum: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLFieldSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFieldSetElement) to Kotlin\n */\npublic external abstract class HTMLFieldSetElement : HTMLElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open val elements: HTMLCollection\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLLegendElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLegendElement) to Kotlin\n */\npublic external abstract class HTMLLegendElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [ValidityState](https://developer.mozilla.org/en/docs/Web/API/ValidityState) to Kotlin\n */\npublic external abstract class ValidityState {\n    open val valueMissing: Boolean\n    open val typeMismatch: Boolean\n    open val patternMismatch: Boolean\n    open val tooLong: Boolean\n    open val tooShort: Boolean\n    open val rangeUnderflow: Boolean\n    open val rangeOverflow: Boolean\n    open val stepMismatch: Boolean\n    open val badInput: Boolean\n    open val customError: Boolean\n    open val valid: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDetailsElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDetailsElement) to Kotlin\n */\npublic external abstract class HTMLDetailsElement : HTMLElement {\n    open var open: Boolean\n}\n\npublic external abstract class HTMLMenuElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var compact: Boolean\n}\n\npublic external abstract class HTMLMenuItemElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var icon: String\n    open var disabled: Boolean\n    open var checked: Boolean\n    open var radiogroup: String\n    open var default: Boolean\n}\n\npublic external open class RelatedEvent(type: String, eventInitDict: RelatedEventInit = definedExternally) : Event {\n    open val relatedTarget: EventTarget?\n}\n\npublic external interface RelatedEventInit : EventInit {\n    var relatedTarget: EventTarget? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RelatedEventInit(relatedTarget: EventTarget? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): RelatedEventInit {\n    val o = js(\"({})\")\n\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLDialogElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDialogElement) to Kotlin\n */\npublic external abstract class HTMLDialogElement : HTMLElement {\n    open var open: Boolean\n    open var returnValue: String\n    fun show(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun showModal(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun close(returnValue: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLScriptElement](https://developer.mozilla.org/en/docs/Web/API/HTMLScriptElement) to Kotlin\n */\npublic external abstract class HTMLScriptElement : HTMLElement, HTMLOrSVGScriptElement {\n    open var src: String\n    open var type: String\n    open var charset: String\n    open var async: Boolean\n    open var defer: Boolean\n    open var crossOrigin: String?\n    open var text: String\n    open var nonce: String\n    open var event: String\n    open var htmlFor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTemplateElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTemplateElement) to Kotlin\n */\npublic external abstract class HTMLTemplateElement : HTMLElement {\n    open val content: DocumentFragment\n}\n\n/**\n * Exposes the JavaScript [HTMLSlotElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSlotElement) to Kotlin\n */\npublic external abstract class HTMLSlotElement : HTMLElement {\n    open var name: String\n    fun assignedNodes(options: AssignedNodesOptions = definedExternally): Array<Node>\n}\n\npublic external interface AssignedNodesOptions {\n    var flatten: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AssignedNodesOptions(flatten: Boolean? = false): AssignedNodesOptions {\n    val o = js(\"({})\")\n\n    o[\"flatten\"] = flatten\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLCanvasElement](https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement) to Kotlin\n */\npublic external abstract class HTMLCanvasElement : HTMLElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    fun getContext(contextId: String, vararg arguments: Any?): RenderingContext?\n    fun toDataURL(type: String = definedExternally, quality: Any? = definedExternally): String\n    fun toBlob(_callback: (Blob?) -> Unit, type: String = definedExternally, quality: Any? = definedExternally): Unit\n}\n\npublic external interface CanvasRenderingContext2DSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CanvasRenderingContext2DSettings(alpha: Boolean? = true): CanvasRenderingContext2DSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D) to Kotlin\n */\npublic external abstract class CanvasRenderingContext2D : CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasHitRegion, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath, RenderingContext {\n    open val canvas: HTMLCanvasElement\n}\n\npublic external interface CanvasState {\n    fun save(): Unit\n    fun restore(): Unit\n}\n\npublic external interface CanvasTransform {\n    fun scale(x: Double, y: Double): Unit\n    fun rotate(angle: Double): Unit\n    fun translate(x: Double, y: Double): Unit\n    fun transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun getTransform(): DOMMatrix\n    fun setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun setTransform(transform: dynamic = definedExternally): Unit\n    fun resetTransform(): Unit\n}\n\npublic external interface CanvasCompositing {\n    var globalAlpha: Double\n    var globalCompositeOperation: String\n}\n\npublic external interface CanvasImageSmoothing {\n    var imageSmoothingEnabled: Boolean\n    var imageSmoothingQuality: ImageSmoothingQuality\n}\n\npublic external interface CanvasFillStrokeStyles {\n    var strokeStyle: dynamic\n    var fillStyle: dynamic\n    fun createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double): CanvasGradient\n    fun createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double): CanvasGradient\n    fun createPattern(image: dynamic, repetition: String): CanvasPattern?\n}\n\npublic external interface CanvasShadowStyles {\n    var shadowOffsetX: Double\n    var shadowOffsetY: Double\n    var shadowBlur: Double\n    var shadowColor: String\n}\n\npublic external interface CanvasFilters {\n    var filter: String\n}\n\npublic external interface CanvasRect {\n    fun clearRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun fillRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun strokeRect(x: Double, y: Double, w: Double, h: Double): Unit\n}\n\npublic external interface CanvasDrawPath {\n    fun beginPath(): Unit\n    fun fill(fillRule: CanvasFillRule = definedExternally): Unit\n    fun fill(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun stroke(): Unit\n    fun stroke(path: Path2D): Unit\n    fun clip(fillRule: CanvasFillRule = definedExternally): Unit\n    fun clip(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun resetClip(): Unit\n    fun isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInStroke(x: Double, y: Double): Boolean\n    fun isPointInStroke(path: Path2D, x: Double, y: Double): Boolean\n}\n\npublic external interface CanvasUserInterface {\n    fun drawFocusIfNeeded(element: Element): Unit\n    fun drawFocusIfNeeded(path: Path2D, element: Element): Unit\n    fun scrollPathIntoView(): Unit\n    fun scrollPathIntoView(path: Path2D): Unit\n}\n\npublic external interface CanvasText {\n    fun fillText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun strokeText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun measureText(text: String): TextMetrics\n}\n\npublic external interface CanvasDrawImage {\n    fun drawImage(image: dynamic, dx: Double, dy: Double): Unit\n    fun drawImage(image: dynamic, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n    fun drawImage(image: dynamic, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n}\n\npublic external interface CanvasHitRegion {\n    fun addHitRegion(options: HitRegionOptions = definedExternally): Unit\n    fun removeHitRegion(id: String): Unit\n    fun clearHitRegions(): Unit\n}\n\npublic external interface CanvasImageData {\n    fun createImageData(sw: Double, sh: Double): ImageData\n    fun createImageData(imagedata: ImageData): ImageData\n    fun getImageData(sx: Double, sy: Double, sw: Double, sh: Double): ImageData\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double): Unit\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double, dirtyX: Double, dirtyY: Double, dirtyWidth: Double, dirtyHeight: Double): Unit\n}\n\npublic external interface CanvasPathDrawingStyles {\n    var lineWidth: Double\n    var lineCap: CanvasLineCap\n    var lineJoin: CanvasLineJoin\n    var miterLimit: Double\n    var lineDashOffset: Double\n    fun setLineDash(segments: Array<Double>): Unit\n    fun getLineDash(): Array<Double>\n}\n\npublic external interface CanvasTextDrawingStyles {\n    var font: String\n    var textAlign: CanvasTextAlign\n    var textBaseline: CanvasTextBaseline\n    var direction: CanvasDirection\n}\n\npublic external interface CanvasPath {\n    fun closePath(): Unit\n    fun moveTo(x: Double, y: Double): Unit\n    fun lineTo(x: Double, y: Double): Unit\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n    fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasGradient](https://developer.mozilla.org/en/docs/Web/API/CanvasGradient) to Kotlin\n */\npublic external abstract class CanvasGradient {\n    fun addColorStop(offset: Double, color: String): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasPattern](https://developer.mozilla.org/en/docs/Web/API/CanvasPattern) to Kotlin\n */\npublic external abstract class CanvasPattern {\n    fun setTransform(transform: dynamic = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [TextMetrics](https://developer.mozilla.org/en/docs/Web/API/TextMetrics) to Kotlin\n */\npublic external abstract class TextMetrics {\n    open val width: Double\n    open val actualBoundingBoxLeft: Double\n    open val actualBoundingBoxRight: Double\n    open val fontBoundingBoxAscent: Double\n    open val fontBoundingBoxDescent: Double\n    open val actualBoundingBoxAscent: Double\n    open val actualBoundingBoxDescent: Double\n    open val emHeightAscent: Double\n    open val emHeightDescent: Double\n    open val hangingBaseline: Double\n    open val alphabeticBaseline: Double\n    open val ideographicBaseline: Double\n}\n\npublic external interface HitRegionOptions {\n    var path: Path2D? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */\n        get() = definedExternally\n        set(value) = definedExternally\n    var id: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var parentID: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cursor: String? /* = \"inherit\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var control: Element? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var label: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var role: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = \"\", parentID: String? = null, cursor: String? = \"inherit\", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions {\n    val o = js(\"({})\")\n\n    o[\"path\"] = path\n    o[\"fillRule\"] = fillRule\n    o[\"id\"] = id\n    o[\"parentID\"] = parentID\n    o[\"cursor\"] = cursor\n    o[\"control\"] = control\n    o[\"label\"] = label\n    o[\"role\"] = role\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin\n */\npublic external open class ImageData : TexImageSource {\n    constructor(sw: Int, sh: Int)\n    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)\n    open val width: Int\n    open val height: Int\n    open val data: Uint8ClampedArray\n}\n\n/**\n * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin\n */\npublic external open class Path2D() : CanvasPath {\n    constructor(path: Path2D)\n    constructor(paths: Array<Path2D>, fillRule: CanvasFillRule = definedExternally)\n    constructor(d: String)\n    fun addPath(path: Path2D, transform: dynamic = definedExternally): Unit\n    override fun closePath(): Unit\n    override fun moveTo(x: Double, y: Double): Unit\n    override fun lineTo(x: Double, y: Double): Unit\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    override fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n}\n\n/**\n * Exposes the JavaScript [Touch](https://developer.mozilla.org/en/docs/Web/API/Touch) to Kotlin\n */\npublic external abstract class Touch {\n    open val region: String?\n}\n\n/**\n * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin\n */\npublic external abstract class ImageBitmapRenderingContext {\n    open val canvas: HTMLCanvasElement\n    fun transferFromImageBitmap(bitmap: ImageBitmap?): Unit\n}\n\npublic external interface ImageBitmapRenderingContextSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapRenderingContextSettings(alpha: Boolean? = true): ImageBitmapRenderingContextSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomElementRegistry](https://developer.mozilla.org/en/docs/Web/API/CustomElementRegistry) to Kotlin\n */\npublic external abstract class CustomElementRegistry {\n    fun define(name: String, constructor: () -> dynamic, options: ElementDefinitionOptions = definedExternally): Unit\n    fun get(name: String): Any?\n    fun whenDefined(name: String): Promise<Unit>\n}\n\npublic external interface ElementDefinitionOptions {\n    var extends: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementDefinitionOptions(extends: String? = null): ElementDefinitionOptions {\n    val o = js(\"({})\")\n\n    o[\"extends\"] = extends\n\n    return o\n}\n\npublic external interface ElementContentEditable {\n    var contentEditable: String\n    val isContentEditable: Boolean\n}\n\n/**\n * Exposes the JavaScript [DataTransfer](https://developer.mozilla.org/en/docs/Web/API/DataTransfer) to Kotlin\n */\npublic external abstract class DataTransfer {\n    open var dropEffect: String\n    open var effectAllowed: String\n    open val items: DataTransferItemList\n    open val types: Array<out String>\n    open val files: FileList\n    fun setDragImage(image: Element, x: Int, y: Int): Unit\n    fun getData(format: String): String\n    fun setData(format: String, data: String): Unit\n    fun clearData(format: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [DataTransferItemList](https://developer.mozilla.org/en/docs/Web/API/DataTransferItemList) to Kotlin\n */\npublic external abstract class DataTransferItemList {\n    open val length: Int\n    fun add(data: String, type: String): DataTransferItem?\n    fun add(data: File): DataTransferItem?\n    fun remove(index: Int): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun DataTransferItemList.get(index: Int): DataTransferItem? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DataTransferItem](https://developer.mozilla.org/en/docs/Web/API/DataTransferItem) to Kotlin\n */\npublic external abstract class DataTransferItem {\n    open val kind: String\n    open val type: String\n    fun getAsString(_callback: ((String) -> Unit)?): Unit\n    fun getAsFile(): File?\n}\n\n/**\n * Exposes the JavaScript [DragEvent](https://developer.mozilla.org/en/docs/Web/API/DragEvent) to Kotlin\n */\npublic external open class DragEvent(type: String, eventInitDict: DragEventInit = definedExternally) : MouseEvent {\n    open val dataTransfer: DataTransfer?\n}\n\npublic external interface DragEventInit : MouseEventInit {\n    var dataTransfer: DataTransfer? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DragEventInit(dataTransfer: DataTransfer? = null, screenX: Int? = 0, screenY: Int? = 0, clientX: Int? = 0, clientY: Int? = 0, button: Short? = 0, buttons: Short? = 0, relatedTarget: EventTarget? = null, ctrlKey: Boolean? = false, shiftKey: Boolean? = false, altKey: Boolean? = false, metaKey: Boolean? = false, modifierAltGraph: Boolean? = false, modifierCapsLock: Boolean? = false, modifierFn: Boolean? = false, modifierFnLock: Boolean? = false, modifierHyper: Boolean? = false, modifierNumLock: Boolean? = false, modifierScrollLock: Boolean? = false, modifierSuper: Boolean? = false, modifierSymbol: Boolean? = false, modifierSymbolLock: Boolean? = false, view: Window? = null, detail: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): DragEventInit {\n    val o = js(\"({})\")\n\n    o[\"dataTransfer\"] = dataTransfer\n    o[\"screenX\"] = screenX\n    o[\"screenY\"] = screenY\n    o[\"clientX\"] = clientX\n    o[\"clientY\"] = clientY\n    o[\"button\"] = button\n    o[\"buttons\"] = buttons\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"ctrlKey\"] = ctrlKey\n    o[\"shiftKey\"] = shiftKey\n    o[\"altKey\"] = altKey\n    o[\"metaKey\"] = metaKey\n    o[\"modifierAltGraph\"] = modifierAltGraph\n    o[\"modifierCapsLock\"] = modifierCapsLock\n    o[\"modifierFn\"] = modifierFn\n    o[\"modifierFnLock\"] = modifierFnLock\n    o[\"modifierHyper\"] = modifierHyper\n    o[\"modifierNumLock\"] = modifierNumLock\n    o[\"modifierScrollLock\"] = modifierScrollLock\n    o[\"modifierSuper\"] = modifierSuper\n    o[\"modifierSymbol\"] = modifierSymbol\n    o[\"modifierSymbolLock\"] = modifierSymbolLock\n    o[\"view\"] = view\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class BarProp {\n    open val visible: Boolean\n}\n\n/**\n * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin\n */\npublic external abstract class History {\n    open val length: Int\n    open var scrollRestoration: ScrollRestoration\n    open val state: Any?\n    fun go(delta: Int = definedExternally): Unit\n    fun back(): Unit\n    fun forward(): Unit\n    fun pushState(data: Any?, title: String, url: String? = definedExternally): Unit\n    fun replaceState(data: Any?, title: String, url: String? = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin\n */\npublic external abstract class Location {\n    open var href: String\n    open val origin: String\n    open var protocol: String\n    open var host: String\n    open var hostname: String\n    open var port: String\n    open var pathname: String\n    open var search: String\n    open var hash: String\n    open val ancestorOrigins: Array<out String>\n    fun assign(url: String): Unit\n    fun replace(url: String): Unit\n    fun reload(): Unit\n}\n\n/**\n * Exposes the JavaScript [PopStateEvent](https://developer.mozilla.org/en/docs/Web/API/PopStateEvent) to Kotlin\n */\npublic external open class PopStateEvent(type: String, eventInitDict: PopStateEventInit = definedExternally) : Event {\n    open val state: Any?\n}\n\npublic external interface PopStateEventInit : EventInit {\n    var state: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PopStateEventInit(state: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PopStateEventInit {\n    val o = js(\"({})\")\n\n    o[\"state\"] = state\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HashChangeEvent](https://developer.mozilla.org/en/docs/Web/API/HashChangeEvent) to Kotlin\n */\npublic external open class HashChangeEvent(type: String, eventInitDict: HashChangeEventInit = definedExternally) : Event {\n    open val oldURL: String\n    open val newURL: String\n}\n\npublic external interface HashChangeEventInit : EventInit {\n    var oldURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HashChangeEventInit(oldURL: String? = \"\", newURL: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): HashChangeEventInit {\n    val o = js(\"({})\")\n\n    o[\"oldURL\"] = oldURL\n    o[\"newURL\"] = newURL\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PageTransitionEvent](https://developer.mozilla.org/en/docs/Web/API/PageTransitionEvent) to Kotlin\n */\npublic external open class PageTransitionEvent(type: String, eventInitDict: PageTransitionEventInit = definedExternally) : Event {\n    open val persisted: Boolean\n}\n\npublic external interface PageTransitionEventInit : EventInit {\n    var persisted: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PageTransitionEventInit(persisted: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PageTransitionEventInit {\n    val o = js(\"({})\")\n\n    o[\"persisted\"] = persisted\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [BeforeUnloadEvent](https://developer.mozilla.org/en/docs/Web/API/BeforeUnloadEvent) to Kotlin\n */\npublic external open class BeforeUnloadEvent : Event {\n    var returnValue: String\n}\n\npublic external abstract class ApplicationCache : EventTarget {\n    open val status: Short\n    open var onchecking: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onnoupdate: ((Event) -> dynamic)?\n    open var ondownloading: ((Event) -> dynamic)?\n    open var onprogress: ((Event) -> dynamic)?\n    open var onupdateready: ((Event) -> dynamic)?\n    open var oncached: ((Event) -> dynamic)?\n    open var onobsolete: ((Event) -> dynamic)?\n    fun update(): Unit\n    fun abort(): Unit\n    fun swapCache(): Unit\n\n    companion object {\n        val UNCACHED: Short\n        val IDLE: Short\n        val CHECKING: Short\n        val DOWNLOADING: Short\n        val UPDATEREADY: Short\n        val OBSOLETE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NavigatorOnLine](https://developer.mozilla.org/en/docs/Web/API/NavigatorOnLine) to Kotlin\n */\npublic external interface NavigatorOnLine {\n    val onLine: Boolean\n}\n\n/**\n * Exposes the JavaScript [ErrorEvent](https://developer.mozilla.org/en/docs/Web/API/ErrorEvent) to Kotlin\n */\npublic external open class ErrorEvent(type: String, eventInitDict: ErrorEventInit = definedExternally) : Event {\n    open val message: String\n    open val filename: String\n    open val lineno: Int\n    open val colno: Int\n    open val error: Any?\n}\n\npublic external interface ErrorEventInit : EventInit {\n    var message: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var filename: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lineno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var error: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ErrorEventInit(message: String? = \"\", filename: String? = \"\", lineno: Int? = 0, colno: Int? = 0, error: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ErrorEventInit {\n    val o = js(\"({})\")\n\n    o[\"message\"] = message\n    o[\"filename\"] = filename\n    o[\"lineno\"] = lineno\n    o[\"colno\"] = colno\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PromiseRejectionEvent](https://developer.mozilla.org/en/docs/Web/API/PromiseRejectionEvent) to Kotlin\n */\npublic external open class PromiseRejectionEvent(type: String, eventInitDict: PromiseRejectionEventInit) : Event {\n    open val promise: Promise<Any?>\n    open val reason: Any?\n}\n\npublic external interface PromiseRejectionEventInit : EventInit {\n    var promise: Promise<Any?>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PromiseRejectionEventInit(promise: Promise<Any?>?, reason: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PromiseRejectionEventInit {\n    val o = js(\"({})\")\n\n    o[\"promise\"] = promise\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GlobalEventHandlers](https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers) to Kotlin\n */\npublic external interface GlobalEventHandlers {\n    var onabort: ((Event) -> dynamic)?\n    var onblur: ((Event) -> dynamic)?\n    var oncancel: ((Event) -> dynamic)?\n    var oncanplay: ((Event) -> dynamic)?\n    var oncanplaythrough: ((Event) -> dynamic)?\n    var onchange: ((Event) -> dynamic)?\n    var onclick: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    var oncontextmenu: ((Event) -> dynamic)?\n    var oncuechange: ((Event) -> dynamic)?\n    var ondblclick: ((Event) -> dynamic)?\n    var ondrag: ((Event) -> dynamic)?\n    var ondragend: ((Event) -> dynamic)?\n    var ondragenter: ((Event) -> dynamic)?\n    var ondragexit: ((Event) -> dynamic)?\n    var ondragleave: ((Event) -> dynamic)?\n    var ondragover: ((Event) -> dynamic)?\n    var ondragstart: ((Event) -> dynamic)?\n    var ondrop: ((Event) -> dynamic)?\n    var ondurationchange: ((Event) -> dynamic)?\n    var onemptied: ((Event) -> dynamic)?\n    var onended: ((Event) -> dynamic)?\n    var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    var onfocus: ((Event) -> dynamic)?\n    var oninput: ((Event) -> dynamic)?\n    var oninvalid: ((Event) -> dynamic)?\n    var onkeydown: ((Event) -> dynamic)?\n    var onkeypress: ((Event) -> dynamic)?\n    var onkeyup: ((Event) -> dynamic)?\n    var onload: ((Event) -> dynamic)?\n    var onloadeddata: ((Event) -> dynamic)?\n    var onloadedmetadata: ((Event) -> dynamic)?\n    var onloadend: ((Event) -> dynamic)?\n    var onloadstart: ((Event) -> dynamic)?\n    var onmousedown: ((Event) -> dynamic)?\n    var onmouseenter: ((Event) -> dynamic)?\n    var onmouseleave: ((Event) -> dynamic)?\n    var onmousemove: ((Event) -> dynamic)?\n    var onmouseout: ((Event) -> dynamic)?\n    var onmouseover: ((Event) -> dynamic)?\n    var onmouseup: ((Event) -> dynamic)?\n    var onwheel: ((Event) -> dynamic)?\n    var onpause: ((Event) -> dynamic)?\n    var onplay: ((Event) -> dynamic)?\n    var onplaying: ((Event) -> dynamic)?\n    var onprogress: ((Event) -> dynamic)?\n    var onratechange: ((Event) -> dynamic)?\n    var onreset: ((Event) -> dynamic)?\n    var onresize: ((Event) -> dynamic)?\n    var onscroll: ((Event) -> dynamic)?\n    var onseeked: ((Event) -> dynamic)?\n    var onseeking: ((Event) -> dynamic)?\n    var onselect: ((Event) -> dynamic)?\n    var onshow: ((Event) -> dynamic)?\n    var onstalled: ((Event) -> dynamic)?\n    var onsubmit: ((Event) -> dynamic)?\n    var onsuspend: ((Event) -> dynamic)?\n    var ontimeupdate: ((Event) -> dynamic)?\n    var ontoggle: ((Event) -> dynamic)?\n    var onvolumechange: ((Event) -> dynamic)?\n    var onwaiting: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowEventHandlers](https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers) to Kotlin\n */\npublic external interface WindowEventHandlers {\n    var onafterprint: ((Event) -> dynamic)?\n    var onbeforeprint: ((Event) -> dynamic)?\n    var onbeforeunload: ((Event) -> String?)?\n    var onhashchange: ((Event) -> dynamic)?\n    var onlanguagechange: ((Event) -> dynamic)?\n    var onmessage: ((Event) -> dynamic)?\n    var onoffline: ((Event) -> dynamic)?\n    var ononline: ((Event) -> dynamic)?\n    var onpagehide: ((Event) -> dynamic)?\n    var onpageshow: ((Event) -> dynamic)?\n    var onpopstate: ((Event) -> dynamic)?\n    var onrejectionhandled: ((Event) -> dynamic)?\n    var onstorage: ((Event) -> dynamic)?\n    var onunhandledrejection: ((Event) -> dynamic)?\n    var onunload: ((Event) -> dynamic)?\n}\n\npublic external interface DocumentAndElementEventHandlers {\n    var oncopy: ((Event) -> dynamic)?\n    var oncut: ((Event) -> dynamic)?\n    var onpaste: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowOrWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WindowOrWorkerGlobalScope) to Kotlin\n */\npublic external interface WindowOrWorkerGlobalScope {\n    val caches: CacheStorage\n    val origin: String\n    fun fetch(input: dynamic, init: RequestInit = definedExternally): Promise<Response>\n    fun btoa(data: String): String\n    fun atob(data: String): String\n    fun setTimeout(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearTimeout(handle: Int = definedExternally): Unit\n    fun setInterval(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearInterval(handle: Int = definedExternally): Unit\n    fun createImageBitmap(image: dynamic, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun createImageBitmap(image: dynamic, sx: Int, sy: Int, sw: Int, sh: Int, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n}\n\n/**\n * Exposes the JavaScript [Navigator](https://developer.mozilla.org/en/docs/Web/API/Navigator) to Kotlin\n */\npublic external abstract class Navigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n    fun vibrate(pattern: dynamic): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorID](https://developer.mozilla.org/en/docs/Web/API/NavigatorID) to Kotlin\n */\npublic external interface NavigatorID {\n    val appCodeName: String\n    val appName: String\n    val appVersion: String\n    val platform: String\n    val product: String\n    val productSub: String\n    val userAgent: String\n    val vendor: String\n    val vendorSub: String\n    val oscpu: String\n    fun taintEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorLanguage](https://developer.mozilla.org/en/docs/Web/API/NavigatorLanguage) to Kotlin\n */\npublic external interface NavigatorLanguage {\n    val language: String\n    val languages: Array<out String>\n}\n\npublic external interface NavigatorContentUtils {\n    fun registerProtocolHandler(scheme: String, url: String, title: String): Unit\n    fun registerContentHandler(mimeType: String, url: String, title: String): Unit\n    fun isProtocolHandlerRegistered(scheme: String, url: String): String\n    fun isContentHandlerRegistered(mimeType: String, url: String): String\n    fun unregisterProtocolHandler(scheme: String, url: String): Unit\n    fun unregisterContentHandler(mimeType: String, url: String): Unit\n}\n\npublic external interface NavigatorCookies {\n    val cookieEnabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorPlugins](https://developer.mozilla.org/en/docs/Web/API/NavigatorPlugins) to Kotlin\n */\npublic external interface NavigatorPlugins {\n    val plugins: PluginArray\n    val mimeTypes: MimeTypeArray\n    fun javaEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [PluginArray](https://developer.mozilla.org/en/docs/Web/API/PluginArray) to Kotlin\n */\npublic external abstract class PluginArray : ItemArrayLike<Plugin> {\n    override val length: Int\n    fun refresh(reload: Boolean = definedExternally): Unit\n    override fun item(index: Int): Plugin?\n    fun namedItem(name: String): Plugin?\n}\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(index: Int): Plugin? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(name: String): Plugin? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeTypeArray](https://developer.mozilla.org/en/docs/Web/API/MimeTypeArray) to Kotlin\n */\npublic external abstract class MimeTypeArray : ItemArrayLike<MimeType> {\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Plugin](https://developer.mozilla.org/en/docs/Web/API/Plugin) to Kotlin\n */\npublic external abstract class Plugin : ItemArrayLike<MimeType> {\n    open val name: String\n    open val description: String\n    open val filename: String\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeType](https://developer.mozilla.org/en/docs/Web/API/MimeType) to Kotlin\n */\npublic external abstract class MimeType {\n    open val type: String\n    open val description: String\n    open val suffixes: String\n    open val enabledPlugin: Plugin\n}\n\n/**\n * Exposes the JavaScript [ImageBitmap](https://developer.mozilla.org/en/docs/Web/API/ImageBitmap) to Kotlin\n */\npublic external abstract class ImageBitmap : TexImageSource {\n    open val width: Int\n    open val height: Int\n    fun close(): Unit\n}\n\npublic external interface ImageBitmapOptions {\n    var imageOrientation: ImageOrientation? /* = ImageOrientation.NONE */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultiplyAlpha: PremultiplyAlpha? /* = PremultiplyAlpha.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colorSpaceConversion: ColorSpaceConversion? /* = ColorSpaceConversion.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeWidth: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeHeight: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeQuality: ResizeQuality? /* = ResizeQuality.LOW */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapOptions(imageOrientation: ImageOrientation? = ImageOrientation.NONE, premultiplyAlpha: PremultiplyAlpha? = PremultiplyAlpha.DEFAULT, colorSpaceConversion: ColorSpaceConversion? = ColorSpaceConversion.DEFAULT, resizeWidth: Int? = null, resizeHeight: Int? = null, resizeQuality: ResizeQuality? = ResizeQuality.LOW): ImageBitmapOptions {\n    val o = js(\"({})\")\n\n    o[\"imageOrientation\"] = imageOrientation\n    o[\"premultiplyAlpha\"] = premultiplyAlpha\n    o[\"colorSpaceConversion\"] = colorSpaceConversion\n    o[\"resizeWidth\"] = resizeWidth\n    o[\"resizeHeight\"] = resizeHeight\n    o[\"resizeQuality\"] = resizeQuality\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageEvent](https://developer.mozilla.org/en/docs/Web/API/MessageEvent) to Kotlin\n */\npublic external open class MessageEvent(type: String, eventInitDict: MessageEventInit = definedExternally) : Event {\n    open val data: Any?\n    open val origin: String\n    open val lastEventId: String\n    open val source: UnionMessagePortOrWindow?\n    open val ports: Array<out MessagePort>\n    fun initMessageEvent(type: String, bubbles: Boolean, cancelable: Boolean, data: Any?, origin: String, lastEventId: String, source: UnionMessagePortOrWindow?, ports: Array<MessagePort>): Unit\n}\n\npublic external interface MessageEventInit : EventInit {\n    var data: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var origin: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lastEventId: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var source: UnionMessagePortOrWindow? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var ports: Array<MessagePort>? /* = arrayOf() */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MessageEventInit(data: Any? = null, origin: String? = \"\", lastEventId: String? = \"\", source: UnionMessagePortOrWindow? = null, ports: Array<MessagePort>? = arrayOf(), bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MessageEventInit {\n    val o = js(\"({})\")\n\n    o[\"data\"] = data\n    o[\"origin\"] = origin\n    o[\"lastEventId\"] = lastEventId\n    o[\"source\"] = source\n    o[\"ports\"] = ports\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [EventSource](https://developer.mozilla.org/en/docs/Web/API/EventSource) to Kotlin\n */\npublic external open class EventSource(url: String, eventSourceInitDict: EventSourceInit = definedExternally) : EventTarget {\n    open val url: String\n    open val withCredentials: Boolean\n    open val readyState: Short\n    var onopen: ((Event) -> dynamic)?\n    var onmessage: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    fun close(): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSED: Short\n    }\n}\n\npublic external interface EventSourceInit {\n    var withCredentials: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventSourceInit(withCredentials: Boolean? = false): EventSourceInit {\n    val o = js(\"({})\")\n\n    o[\"withCredentials\"] = withCredentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [WebSocket](https://developer.mozilla.org/en/docs/Web/API/WebSocket) to Kotlin\n */\npublic external open class WebSocket(url: String, protocols: dynamic = definedExternally) : EventTarget {\n    open val url: String\n    open val readyState: Short\n    open val bufferedAmount: Int\n    var onopen: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    open val extensions: String\n    open val protocol: String\n    var onmessage: ((Event) -> dynamic)?\n    var binaryType: BinaryType\n    fun close(code: Short = definedExternally, reason: String = definedExternally): Unit\n    fun send(data: String): Unit\n    fun send(data: Blob): Unit\n    fun send(data: ArrayBuffer): Unit\n    fun send(data: ArrayBufferView): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSING: Short\n        val CLOSED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CloseEvent](https://developer.mozilla.org/en/docs/Web/API/CloseEvent) to Kotlin\n */\npublic external open class CloseEvent(type: String, eventInitDict: CloseEventInit = definedExternally) : Event {\n    open val wasClean: Boolean\n    open val code: Short\n    open val reason: String\n}\n\npublic external interface CloseEventInit : EventInit {\n    var wasClean: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var code: Short? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CloseEventInit(wasClean: Boolean? = false, code: Short? = 0, reason: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CloseEventInit {\n    val o = js(\"({})\")\n\n    o[\"wasClean\"] = wasClean\n    o[\"code\"] = code\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageChannel](https://developer.mozilla.org/en/docs/Web/API/MessageChannel) to Kotlin\n */\npublic external open class MessageChannel {\n    open val port1: MessagePort\n    open val port2: MessagePort\n}\n\n/**\n * Exposes the JavaScript [MessagePort](https://developer.mozilla.org/en/docs/Web/API/MessagePort) to Kotlin\n */\npublic external abstract class MessagePort : EventTarget, UnionMessagePortOrWindow, UnionMessagePortOrServiceWorker, UnionClientOrMessagePortOrServiceWorker {\n    open var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun start(): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [BroadcastChannel](https://developer.mozilla.org/en/docs/Web/API/BroadcastChannel) to Kotlin\n */\npublic external open class BroadcastChannel(name: String) : EventTarget {\n    open val name: String\n    var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [WorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WorkerGlobalScope) to Kotlin\n */\npublic external abstract class WorkerGlobalScope : EventTarget, WindowOrWorkerGlobalScope, GlobalPerformance {\n    open val self: WorkerGlobalScope\n    open val location: WorkerLocation\n    open val navigator: WorkerNavigator\n    open var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    open var onlanguagechange: ((Event) -> dynamic)?\n    open var onoffline: ((Event) -> dynamic)?\n    open var ononline: ((Event) -> dynamic)?\n    open var onrejectionhandled: ((Event) -> dynamic)?\n    open var onunhandledrejection: ((Event) -> dynamic)?\n    fun importScripts(vararg urls: String): Unit\n}\n\n/**\n * Exposes the JavaScript [DedicatedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/DedicatedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class DedicatedWorkerGlobalScope : WorkerGlobalScope {\n    open var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [SharedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/SharedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class SharedWorkerGlobalScope : WorkerGlobalScope {\n    open val name: String\n    open val applicationCache: ApplicationCache\n    open var onconnect: ((Event) -> dynamic)?\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [AbstractWorker](https://developer.mozilla.org/en/docs/Web/API/AbstractWorker) to Kotlin\n */\npublic external interface AbstractWorker {\n    var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) to Kotlin\n */\npublic external open class Worker(scriptURL: String, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    var onmessage: ((Event) -> dynamic)?\n    override var onerror: ((Event) -> dynamic)?\n    fun terminate(): Unit\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n}\n\npublic external interface WorkerOptions {\n    var type: WorkerType? /* = WorkerType.CLASSIC */\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials? /* = RequestCredentials.OMIT */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WorkerOptions(type: WorkerType? = WorkerType.CLASSIC, credentials: RequestCredentials? = RequestCredentials.OMIT): WorkerOptions {\n    val o = js(\"({})\")\n\n    o[\"type\"] = type\n    o[\"credentials\"] = credentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [SharedWorker](https://developer.mozilla.org/en/docs/Web/API/SharedWorker) to Kotlin\n */\npublic external open class SharedWorker(scriptURL: String, name: String = definedExternally, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    open val port: MessagePort\n    override var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [NavigatorConcurrentHardware](https://developer.mozilla.org/en/docs/Web/API/NavigatorConcurrentHardware) to Kotlin\n */\npublic external interface NavigatorConcurrentHardware {\n    val hardwareConcurrency: Int\n}\n\n/**\n * Exposes the JavaScript [WorkerNavigator](https://developer.mozilla.org/en/docs/Web/API/WorkerNavigator) to Kotlin\n */\npublic external abstract class WorkerNavigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n}\n\n/**\n * Exposes the JavaScript [WorkerLocation](https://developer.mozilla.org/en/docs/Web/API/WorkerLocation) to Kotlin\n */\npublic external abstract class WorkerLocation {\n    open var href: String\n    open val origin: String\n    open val protocol: String\n    open val host: String\n    open val hostname: String\n    open val port: String\n    open val pathname: String\n    open val search: String\n    open val hash: String\n}\n\n/**\n * Exposes the JavaScript [Storage](https://developer.mozilla.org/en/docs/Web/API/Storage) to Kotlin\n */\npublic external abstract class Storage {\n    open val length: Int\n    fun key(index: Int): String?\n    fun getItem(key: String): String?\n    fun setItem(key: String, value: String): Unit\n    fun removeItem(key: String): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun Storage.get(key: String): String? = asDynamic()[key]\n@kotlin.internal.InlineOnly inline operator fun Storage.set(key: String, value: String): Unit { asDynamic()[key] = value; }\n\n/**\n * Exposes the JavaScript [WindowSessionStorage](https://developer.mozilla.org/en/docs/Web/API/WindowSessionStorage) to Kotlin\n */\npublic external interface WindowSessionStorage {\n    val sessionStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [WindowLocalStorage](https://developer.mozilla.org/en/docs/Web/API/WindowLocalStorage) to Kotlin\n */\npublic external interface WindowLocalStorage {\n    val localStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [StorageEvent](https://developer.mozilla.org/en/docs/Web/API/StorageEvent) to Kotlin\n */\npublic external open class StorageEvent(type: String, eventInitDict: StorageEventInit = definedExternally) : Event {\n    open val key: String?\n    open val oldValue: String?\n    open val newValue: String?\n    open val url: String\n    open val storageArea: Storage?\n}\n\npublic external interface StorageEventInit : EventInit {\n    var key: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var oldValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var url: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var storageArea: Storage? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun StorageEventInit(key: String? = null, oldValue: String? = null, newValue: String? = null, url: String? = \"\", storageArea: Storage? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): StorageEventInit {\n    val o = js(\"({})\")\n\n    o[\"key\"] = key\n    o[\"oldValue\"] = oldValue\n    o[\"newValue\"] = newValue\n    o[\"url\"] = url\n    o[\"storageArea\"] = storageArea\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class HTMLAppletElement : HTMLElement {\n    open var align: String\n    open var alt: String\n    open var archive: String\n    open var code: String\n    open var codeBase: String\n    open var height: String\n    open var hspace: Int\n    open var name: String\n    open var _object: String\n    open var vspace: Int\n    open var width: String\n}\n\npublic external abstract class HTMLMarqueeElement : HTMLElement {\n    open var behavior: String\n    open var bgColor: String\n    open var direction: String\n    open var height: String\n    open var hspace: Int\n    open var loop: Int\n    open var scrollAmount: Int\n    open var scrollDelay: Int\n    open var trueSpeed: Boolean\n    open var vspace: Int\n    open var width: String\n    open var onbounce: ((Event) -> dynamic)?\n    open var onfinish: ((Event) -> dynamic)?\n    open var onstart: ((Event) -> dynamic)?\n    fun start(): Unit\n    fun stop(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLFrameSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFrameSetElement) to Kotlin\n */\npublic external abstract class HTMLFrameSetElement : HTMLElement, WindowEventHandlers {\n    open var cols: String\n    open var rows: String\n}\n\npublic external abstract class HTMLFrameElement : HTMLElement {\n    open var name: String\n    open var scrolling: String\n    open var src: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var noResize: Boolean\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var marginHeight: String\n    open var marginWidth: String\n}\n\npublic external abstract class HTMLDirectoryElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLFontElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFontElement) to Kotlin\n */\npublic external abstract class HTMLFontElement : HTMLElement {\n    open var color: String\n    open var face: String\n    open var size: String\n}\n\npublic external interface External {\n    fun AddSearchProvider(): Unit\n    fun IsSearchProviderInstalled(): Unit\n}\n\npublic external interface EventInit {\n    var bubbles: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cancelable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventInit(bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): EventInit {\n    val o = js(\"({})\")\n\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent) to Kotlin\n */\npublic external open class CustomEvent(type: String, eventInitDict: CustomEventInit = definedExternally) : Event {\n    open val detail: Any?\n    fun initCustomEvent(type: String, bubbles: Boolean, cancelable: Boolean, detail: Any?): Unit\n}\n\npublic external interface CustomEventInit : EventInit {\n    var detail: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CustomEventInit(detail: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CustomEventInit {\n    val o = js(\"({})\")\n\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external interface EventListenerOptions {\n    var capture: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventListenerOptions(capture: Boolean? = false): EventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface AddEventListenerOptions : EventListenerOptions {\n    var passive: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var once: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AddEventListenerOptions(passive: Boolean? = false, once: Boolean? = false, capture: Boolean? = false): AddEventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"passive\"] = passive\n    o[\"once\"] = once\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface NonElementParentNode {\n    fun getElementById(elementId: String): Element?\n}\n\n/**\n * Exposes the JavaScript [DocumentOrShadowRoot](https://developer.mozilla.org/en/docs/Web/API/DocumentOrShadowRoot) to Kotlin\n */\npublic external interface DocumentOrShadowRoot {\n    val fullscreenElement: Element?\n}\n\n/**\n * Exposes the JavaScript [ParentNode](https://developer.mozilla.org/en/docs/Web/API/ParentNode) to Kotlin\n */\npublic external interface ParentNode {\n    val children: HTMLCollection\n    val firstElementChild: Element?\n    val lastElementChild: Element?\n    val childElementCount: Int\n    fun prepend(vararg nodes: dynamic): Unit\n    fun append(vararg nodes: dynamic): Unit\n    fun querySelector(selectors: String): Element?\n    fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [NonDocumentTypeChildNode](https://developer.mozilla.org/en/docs/Web/API/NonDocumentTypeChildNode) to Kotlin\n */\npublic external interface NonDocumentTypeChildNode {\n    val previousElementSibling: Element?\n    val nextElementSibling: Element?\n}\n\n/**\n * Exposes the JavaScript [ChildNode](https://developer.mozilla.org/en/docs/Web/API/ChildNode) to Kotlin\n */\npublic external interface ChildNode {\n    fun before(vararg nodes: dynamic): Unit\n    fun after(vararg nodes: dynamic): Unit\n    fun replaceWith(vararg nodes: dynamic): Unit\n    fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Slotable](https://developer.mozilla.org/en/docs/Web/API/Slotable) to Kotlin\n */\npublic external interface Slotable {\n    val assignedSlot: HTMLSlotElement?\n}\n\n/**\n * Exposes the JavaScript [NodeList](https://developer.mozilla.org/en/docs/Web/API/NodeList) to Kotlin\n */\npublic external abstract class NodeList : ItemArrayLike<Node> {\n    override val length: Int\n    override fun item(index: Int): Node?\n}\n@kotlin.internal.InlineOnly inline operator fun NodeList.get(index: Int): Node? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [HTMLCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLCollection) to Kotlin\n */\npublic external abstract class HTMLCollection : UnionElementOrHTMLCollection, ItemArrayLike<Element> {\n    override val length: Int\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): Element?\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(name: String): Element? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) to Kotlin\n */\npublic external open class MutationObserver(callback: (Array<MutationRecord>, MutationObserver) -> Unit) {\n    fun observe(target: Node, options: MutationObserverInit = definedExternally): Unit\n    fun disconnect(): Unit\n    fun takeRecords(): Array<MutationRecord>\n}\n\npublic external interface MutationObserverInit {\n    var childList: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributes: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterData: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var subtree: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterDataOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeFilter: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MutationObserverInit(childList: Boolean? = false, attributes: Boolean? = null, characterData: Boolean? = null, subtree: Boolean? = false, attributeOldValue: Boolean? = null, characterDataOldValue: Boolean? = null, attributeFilter: Array<String>? = null): MutationObserverInit {\n    val o = js(\"({})\")\n\n    o[\"childList\"] = childList\n    o[\"attributes\"] = attributes\n    o[\"characterData\"] = characterData\n    o[\"subtree\"] = subtree\n    o[\"attributeOldValue\"] = attributeOldValue\n    o[\"characterDataOldValue\"] = characterDataOldValue\n    o[\"attributeFilter\"] = attributeFilter\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MutationRecord](https://developer.mozilla.org/en/docs/Web/API/MutationRecord) to Kotlin\n */\npublic external abstract class MutationRecord {\n    open val type: String\n    open val target: Node\n    open val addedNodes: NodeList\n    open val removedNodes: NodeList\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open val attributeName: String?\n    open val attributeNamespace: String?\n    open val oldValue: String?\n}\n\n/**\n * Exposes the JavaScript [Node](https://developer.mozilla.org/en/docs/Web/API/Node) to Kotlin\n */\npublic external abstract class Node : EventTarget {\n    open val nodeType: Short\n    open val nodeName: String\n    open val baseURI: String\n    open val isConnected: Boolean\n    open val ownerDocument: Document?\n    open val parentNode: Node?\n    open val parentElement: Element?\n    open val childNodes: NodeList\n    open val firstChild: Node?\n    open val lastChild: Node?\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open var nodeValue: String?\n    open var textContent: String?\n    fun getRootNode(options: GetRootNodeOptions = definedExternally): Node\n    fun hasChildNodes(): Boolean\n    fun normalize(): Unit\n    fun cloneNode(deep: Boolean = definedExternally): Node\n    fun isEqualNode(otherNode: Node?): Boolean\n    fun isSameNode(otherNode: Node?): Boolean\n    fun compareDocumentPosition(other: Node): Short\n    fun contains(other: Node?): Boolean\n    fun lookupPrefix(namespace: String?): String?\n    fun lookupNamespaceURI(prefix: String?): String?\n    fun isDefaultNamespace(namespace: String?): Boolean\n    fun insertBefore(node: Node, child: Node?): Node\n    fun appendChild(node: Node): Node\n    fun replaceChild(node: Node, child: Node): Node\n    fun removeChild(child: Node): Node\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface GetRootNodeOptions {\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun GetRootNodeOptions(composed: Boolean? = false): GetRootNodeOptions {\n    val o = js(\"({})\")\n\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [XMLDocument](https://developer.mozilla.org/en/docs/Web/API/XMLDocument) to Kotlin\n */\npublic external open class XMLDocument : Document {\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\npublic external interface ElementCreationOptions {\n    @JsName(\"is\") var is_: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementCreationOptions(is_: String? = null): ElementCreationOptions {\n    val o = js(\"({})\")\n\n    o[\"is\"] = is_\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMImplementation](https://developer.mozilla.org/en/docs/Web/API/DOMImplementation) to Kotlin\n */\npublic external abstract class DOMImplementation {\n    fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType\n    fun createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = definedExternally): XMLDocument\n    fun createHTMLDocument(title: String = definedExternally): Document\n    fun hasFeature(): Boolean\n}\n\n/**\n * Exposes the JavaScript [DocumentType](https://developer.mozilla.org/en/docs/Web/API/DocumentType) to Kotlin\n */\npublic external abstract class DocumentType : Node, ChildNode {\n    open val name: String\n    open val publicId: String\n    open val systemId: String\n}\n\n/**\n * Exposes the JavaScript [DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) to Kotlin\n */\npublic external open class DocumentFragment : Node, NonElementParentNode, ParentNode {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [ShadowRoot](https://developer.mozilla.org/en/docs/Web/API/ShadowRoot) to Kotlin\n */\npublic external open class ShadowRoot : DocumentFragment, DocumentOrShadowRoot {\n    open val mode: ShadowRootMode\n    open val host: Element\n    override val fullscreenElement: Element?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [Element](https://developer.mozilla.org/en/docs/Web/API/Element) to Kotlin\n */\npublic external abstract class Element : Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, GeometryUtils, UnionElementOrProcessingInstruction, UnionElementOrHTMLCollection, UnionElementOrRadioNodeList, UnionElementOrMouseEvent {\n    open var innerHTML: String\n    open var outerHTML: String\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val tagName: String\n    open var id: String\n    open var className: String\n    open val classList: DOMTokenList\n    open var slot: String\n    open val attributes: NamedNodeMap\n    open val shadowRoot: ShadowRoot?\n    open var scrollTop: Double\n    open var scrollLeft: Double\n    open val scrollWidth: Int\n    open val scrollHeight: Int\n    open val clientTop: Int\n    open val clientLeft: Int\n    open val clientWidth: Int\n    open val clientHeight: Int\n    fun requestFullscreen(): Promise<Unit>\n    fun insertAdjacentHTML(position: String, text: String): Unit\n    fun hasAttributes(): Boolean\n    fun getAttributeNames(): Array<String>\n    fun getAttribute(qualifiedName: String): String?\n    fun getAttributeNS(namespace: String?, localName: String): String?\n    fun setAttribute(qualifiedName: String, value: String): Unit\n    fun setAttributeNS(namespace: String?, qualifiedName: String, value: String): Unit\n    fun removeAttribute(qualifiedName: String): Unit\n    fun removeAttributeNS(namespace: String?, localName: String): Unit\n    fun hasAttribute(qualifiedName: String): Boolean\n    fun hasAttributeNS(namespace: String?, localName: String): Boolean\n    fun getAttributeNode(qualifiedName: String): Attr?\n    fun getAttributeNodeNS(namespace: String?, localName: String): Attr?\n    fun setAttributeNode(attr: Attr): Attr?\n    fun setAttributeNodeNS(attr: Attr): Attr?\n    fun removeAttributeNode(attr: Attr): Attr\n    fun attachShadow(init: ShadowRootInit): ShadowRoot\n    fun closest(selectors: String): Element?\n    fun matches(selectors: String): Boolean\n    fun webkitMatchesSelector(selectors: String): Boolean\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun insertAdjacentElement(where: String, element: Element): Element?\n    fun insertAdjacentText(where: String, data: String): Unit\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun scrollIntoView(): Unit\n    fun scrollIntoView(arg: dynamic): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n}\n\npublic external interface ShadowRootInit {\n    var mode: ShadowRootMode?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ShadowRootInit(mode: ShadowRootMode?): ShadowRootInit {\n    val o = js(\"({})\")\n\n    o[\"mode\"] = mode\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [NamedNodeMap](https://developer.mozilla.org/en/docs/Web/API/NamedNodeMap) to Kotlin\n */\npublic external abstract class NamedNodeMap : ItemArrayLike<Attr> {\n    override val length: Int\n    override fun item(index: Int): Attr?\n    fun getNamedItem(qualifiedName: String): Attr?\n    fun getNamedItemNS(namespace: String?, localName: String): Attr?\n    fun setNamedItem(attr: Attr): Attr?\n    fun setNamedItemNS(attr: Attr): Attr?\n    fun removeNamedItem(qualifiedName: String): Attr\n    fun removeNamedItemNS(namespace: String?, localName: String): Attr\n}\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(index: Int): Attr? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(qualifiedName: String): Attr? = asDynamic()[qualifiedName]\n\n/**\n * Exposes the JavaScript [Attr](https://developer.mozilla.org/en/docs/Web/API/Attr) to Kotlin\n */\npublic external abstract class Attr : Node {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val name: String\n    open var value: String\n    open val ownerElement: Element?\n    open val specified: Boolean\n}\n\n/**\n * Exposes the JavaScript [CharacterData](https://developer.mozilla.org/en/docs/Web/API/CharacterData) to Kotlin\n */\npublic external abstract class CharacterData : Node, NonDocumentTypeChildNode, ChildNode {\n    open var data: String\n    open val length: Int\n    fun substringData(offset: Int, count: Int): String\n    fun appendData(data: String): Unit\n    fun insertData(offset: Int, data: String): Unit\n    fun deleteData(offset: Int, count: Int): Unit\n    fun replaceData(offset: Int, count: Int, data: String): Unit\n}\n\n/**\n * Exposes the JavaScript [Text](https://developer.mozilla.org/en/docs/Web/API/Text) to Kotlin\n */\npublic external open class Text(data: String = definedExternally) : CharacterData, Slotable, GeometryUtils {\n    open val wholeText: String\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    fun splitText(offset: Int): Text\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [CDATASection](https://developer.mozilla.org/en/docs/Web/API/CDATASection) to Kotlin\n */\npublic external open class CDATASection : Text {\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [ProcessingInstruction](https://developer.mozilla.org/en/docs/Web/API/ProcessingInstruction) to Kotlin\n */\npublic external abstract class ProcessingInstruction : CharacterData, LinkStyle, UnionElementOrProcessingInstruction {\n    open val target: String\n}\n\n/**\n * Exposes the JavaScript [Comment](https://developer.mozilla.org/en/docs/Web/API/Comment) to Kotlin\n */\npublic external open class Comment(data: String = definedExternally) : CharacterData {\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Range](https://developer.mozilla.org/en/docs/Web/API/Range) to Kotlin\n */\npublic external open class Range {\n    open val startContainer: Node\n    open val startOffset: Int\n    open val endContainer: Node\n    open val endOffset: Int\n    open val collapsed: Boolean\n    open val commonAncestorContainer: Node\n    fun createContextualFragment(fragment: String): DocumentFragment\n    fun setStart(node: Node, offset: Int): Unit\n    fun setEnd(node: Node, offset: Int): Unit\n    fun setStartBefore(node: Node): Unit\n    fun setStartAfter(node: Node): Unit\n    fun setEndBefore(node: Node): Unit\n    fun setEndAfter(node: Node): Unit\n    fun collapse(toStart: Boolean = definedExternally): Unit\n    fun selectNode(node: Node): Unit\n    fun selectNodeContents(node: Node): Unit\n    fun compareBoundaryPoints(how: Short, sourceRange: Range): Short\n    fun deleteContents(): Unit\n    fun extractContents(): DocumentFragment\n    fun cloneContents(): DocumentFragment\n    fun insertNode(node: Node): Unit\n    fun surroundContents(newParent: Node): Unit\n    fun cloneRange(): Range\n    fun detach(): Unit\n    fun isPointInRange(node: Node, offset: Int): Boolean\n    fun comparePoint(node: Node, offset: Int): Short\n    fun intersectsNode(node: Node): Boolean\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n\n    companion object {\n        val START_TO_START: Short\n        val START_TO_END: Short\n        val END_TO_END: Short\n        val END_TO_START: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NodeIterator](https://developer.mozilla.org/en/docs/Web/API/NodeIterator) to Kotlin\n */\npublic external abstract class NodeIterator {\n    open val root: Node\n    open val referenceNode: Node\n    open val pointerBeforeReferenceNode: Boolean\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    fun nextNode(): Node?\n    fun previousNode(): Node?\n    fun detach(): Unit\n}\n\n/**\n * Exposes the JavaScript [TreeWalker](https://developer.mozilla.org/en/docs/Web/API/TreeWalker) to Kotlin\n */\npublic external abstract class TreeWalker {\n    open val root: Node\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    open var currentNode: Node\n    fun parentNode(): Node?\n    fun firstChild(): Node?\n    fun lastChild(): Node?\n    fun previousSibling(): Node?\n    fun nextSibling(): Node?\n    fun previousNode(): Node?\n    fun nextNode(): Node?\n}\n\n/**\n * Exposes the JavaScript [NodeFilter](https://developer.mozilla.org/en/docs/Web/API/NodeFilter) to Kotlin\n */\npublic external interface NodeFilter {\n    fun acceptNode(node: Node): Short\n\n    companion object {\n        val FILTER_ACCEPT: Short\n        val FILTER_REJECT: Short\n        val FILTER_SKIP: Short\n        val SHOW_ALL: Int\n        val SHOW_ELEMENT: Int\n        val SHOW_ATTRIBUTE: Int\n        val SHOW_TEXT: Int\n        val SHOW_CDATA_SECTION: Int\n        val SHOW_ENTITY_REFERENCE: Int\n        val SHOW_ENTITY: Int\n        val SHOW_PROCESSING_INSTRUCTION: Int\n        val SHOW_COMMENT: Int\n        val SHOW_DOCUMENT: Int\n        val SHOW_DOCUMENT_TYPE: Int\n        val SHOW_DOCUMENT_FRAGMENT: Int\n        val SHOW_NOTATION: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMTokenList](https://developer.mozilla.org/en/docs/Web/API/DOMTokenList) to Kotlin\n */\npublic external abstract class DOMTokenList : ItemArrayLike<String> {\n    override val length: Int\n    open var value: String\n    override fun item(index: Int): String?\n    fun contains(token: String): Boolean\n    fun add(vararg tokens: String): Unit\n    fun remove(vararg tokens: String): Unit\n    fun toggle(token: String, force: Boolean = definedExternally): Boolean\n    fun replace(token: String, newToken: String): Unit\n    fun supports(token: String): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun DOMTokenList.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMPointReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMPointReadOnly) to Kotlin\n */\npublic external open class DOMPointReadOnly(x: Double, y: Double, z: Double, w: Double) {\n    open val x: Double\n    open val y: Double\n    open val z: Double\n    open val w: Double\n    fun matrixTransform(matrix: DOMMatrixReadOnly): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [DOMPoint](https://developer.mozilla.org/en/docs/Web/API/DOMPoint) to Kotlin\n */\npublic external open class DOMPoint : DOMPointReadOnly {\n    constructor(point: DOMPointInit)\n    constructor(x: Double = definedExternally, y: Double = definedExternally, z: Double = definedExternally, w: Double = definedExternally)\n    override var x: Double\n    override var y: Double\n    override var z: Double\n    override var w: Double\n}\n\npublic external interface DOMPointInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var z: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var w: Double? /* = 1.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMPointInit(x: Double? = 0.0, y: Double? = 0.0, z: Double? = 0.0, w: Double? = 1.0): DOMPointInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"z\"] = z\n    o[\"w\"] = w\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMRect](https://developer.mozilla.org/en/docs/Web/API/DOMRect) to Kotlin\n */\npublic external open class DOMRect(x: Double = definedExternally, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally) : DOMRectReadOnly {\n    override var x: Double\n    override var y: Double\n    override var width: Double\n    override var height: Double\n}\n\n/**\n * Exposes the JavaScript [DOMRectReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMRectReadOnly) to Kotlin\n */\npublic external open class DOMRectReadOnly(x: Double, y: Double, width: Double, height: Double) {\n    open val x: Double\n    open val y: Double\n    open val width: Double\n    open val height: Double\n    open val top: Double\n    open val right: Double\n    open val bottom: Double\n    open val left: Double\n}\n\npublic external interface DOMRectInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var width: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMRectInit(x: Double? = 0.0, y: Double? = 0.0, width: Double? = 0.0, height: Double? = 0.0): DOMRectInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"width\"] = width\n    o[\"height\"] = height\n\n    return o\n}\n\npublic external interface DOMRectList : ItemArrayLike<DOMRect> {\n    override fun item(index: Int): DOMRect?\n}\n@kotlin.internal.InlineOnly inline operator fun DOMRectList.get(index: Int): DOMRect? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMQuad](https://developer.mozilla.org/en/docs/Web/API/DOMQuad) to Kotlin\n */\npublic external open class DOMQuad {\n    constructor(p1: DOMPointInit = definedExternally, p2: DOMPointInit = definedExternally, p3: DOMPointInit = definedExternally, p4: DOMPointInit = definedExternally)\n    constructor(rect: DOMRectInit)\n    open val p1: DOMPoint\n    open val p2: DOMPoint\n    open val p3: DOMPoint\n    open val p4: DOMPoint\n    open val bounds: DOMRectReadOnly\n}\n\n/**\n * Exposes the JavaScript [DOMMatrixReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMMatrixReadOnly) to Kotlin\n */\npublic external open class DOMMatrixReadOnly(numberSequence: Array<Double>) {\n    open val a: Double\n    open val b: Double\n    open val c: Double\n    open val d: Double\n    open val e: Double\n    open val f: Double\n    open val m11: Double\n    open val m12: Double\n    open val m13: Double\n    open val m14: Double\n    open val m21: Double\n    open val m22: Double\n    open val m23: Double\n    open val m24: Double\n    open val m31: Double\n    open val m32: Double\n    open val m33: Double\n    open val m34: Double\n    open val m41: Double\n    open val m42: Double\n    open val m43: Double\n    open val m44: Double\n    open val is2D: Boolean\n    open val isIdentity: Boolean\n    fun translate(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scale(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3d(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniform(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotate(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVector(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngle(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewX(sx: Double): DOMMatrix\n    fun skewY(sy: Double): DOMMatrix\n    fun multiply(other: DOMMatrix): DOMMatrix\n    fun flipX(): DOMMatrix\n    fun flipY(): DOMMatrix\n    fun inverse(): DOMMatrix\n    fun transformPoint(point: DOMPointInit = definedExternally): DOMPoint\n    fun toFloat32Array(): Float32Array\n    fun toFloat64Array(): Float64Array\n}\n\n/**\n * Exposes the JavaScript [DOMMatrix](https://developer.mozilla.org/en/docs/Web/API/DOMMatrix) to Kotlin\n */\npublic external open class DOMMatrix() : DOMMatrixReadOnly {\n    constructor(transformList: String)\n    constructor(other: DOMMatrixReadOnly)\n    constructor(array32: Float32Array)\n    constructor(array64: Float64Array)\n    constructor(numberSequence: Array<Double>)\n    override var a: Double\n    override var b: Double\n    override var c: Double\n    override var d: Double\n    override var e: Double\n    override var f: Double\n    override var m11: Double\n    override var m12: Double\n    override var m13: Double\n    override var m14: Double\n    override var m21: Double\n    override var m22: Double\n    override var m23: Double\n    override var m24: Double\n    override var m31: Double\n    override var m32: Double\n    override var m33: Double\n    override var m34: Double\n    override var m41: Double\n    override var m42: Double\n    override var m43: Double\n    override var m44: Double\n    fun multiplySelf(other: DOMMatrix): DOMMatrix\n    fun preMultiplySelf(other: DOMMatrix): DOMMatrix\n    fun translateSelf(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scaleSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3dSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniformSelf(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotateSelf(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVectorSelf(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngleSelf(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewXSelf(sx: Double): DOMMatrix\n    fun skewYSelf(sy: Double): DOMMatrix\n    fun invertSelf(): DOMMatrix\n    fun setMatrixValue(transformList: String): DOMMatrix\n}\n\npublic external interface ScrollOptions {\n    var behavior: ScrollBehavior? /* = ScrollBehavior.AUTO */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollOptions(behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollOptions {\n    val o = js(\"({})\")\n\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\npublic external interface ScrollToOptions : ScrollOptions {\n    var left: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var top: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollToOptions(left: Double? = null, top: Double? = null, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollToOptions {\n    val o = js(\"({})\")\n\n    o[\"left\"] = left\n    o[\"top\"] = top\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaQueryList](https://developer.mozilla.org/en/docs/Web/API/MediaQueryList) to Kotlin\n */\npublic external abstract class MediaQueryList : EventTarget {\n    open val media: String\n    open val matches: Boolean\n    open var onchange: ((Event) -> dynamic)?\n    fun addListener(listener: EventListener?): Unit\n    fun addListener(listener: ((Event) -> Unit)?): Unit\n    fun removeListener(listener: EventListener?): Unit\n    fun removeListener(listener: ((Event) -> Unit)?): Unit\n}\n\n/**\n * Exposes the JavaScript [MediaQueryListEvent](https://developer.mozilla.org/en/docs/Web/API/MediaQueryListEvent) to Kotlin\n */\npublic external open class MediaQueryListEvent(type: String, eventInitDict: MediaQueryListEventInit = definedExternally) : Event {\n    open val media: String\n    open val matches: Boolean\n}\n\npublic external interface MediaQueryListEventInit : EventInit {\n    var media: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var matches: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaQueryListEventInit(media: String? = \"\", matches: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaQueryListEventInit {\n    val o = js(\"({})\")\n\n    o[\"media\"] = media\n    o[\"matches\"] = matches\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [Screen](https://developer.mozilla.org/en/docs/Web/API/Screen) to Kotlin\n */\npublic external abstract class Screen {\n    open val availWidth: Int\n    open val availHeight: Int\n    open val width: Int\n    open val height: Int\n    open val colorDepth: Int\n    open val pixelDepth: Int\n}\n\n/**\n * Exposes the JavaScript [CaretPosition](https://developer.mozilla.org/en/docs/Web/API/CaretPosition) to Kotlin\n */\npublic external abstract class CaretPosition {\n    open val offsetNode: Node\n    open val offset: Int\n    fun getClientRect(): DOMRect?\n}\n\npublic external interface ScrollIntoViewOptions : ScrollOptions {\n    var block: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var inline: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollIntoViewOptions(block: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, inline: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollIntoViewOptions {\n    val o = js(\"({})\")\n\n    o[\"block\"] = block\n    o[\"inline\"] = inline\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\npublic external interface BoxQuadOptions {\n    var box: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var relativeTo: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BoxQuadOptions(box: CSSBoxType? = CSSBoxType.BORDER, relativeTo: dynamic = null): BoxQuadOptions {\n    val o = js(\"({})\")\n\n    o[\"box\"] = box\n    o[\"relativeTo\"] = relativeTo\n\n    return o\n}\n\npublic external interface ConvertCoordinateOptions {\n    var fromBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var toBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConvertCoordinateOptions(fromBox: CSSBoxType? = CSSBoxType.BORDER, toBox: CSSBoxType? = CSSBoxType.BORDER): ConvertCoordinateOptions {\n    val o = js(\"({})\")\n\n    o[\"fromBox\"] = fromBox\n    o[\"toBox\"] = toBox\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GeometryUtils](https://developer.mozilla.org/en/docs/Web/API/GeometryUtils) to Kotlin\n */\npublic external interface GeometryUtils {\n    fun getBoxQuads(options: BoxQuadOptions = definedExternally): Array<DOMQuad>\n    fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMPoint\n}\n\npublic external @marker interface UnionElementOrProcessingInstruction {\n}\n\npublic external @marker interface UnionElementOrHTMLCollection {\n}\n\npublic external @marker interface UnionElementOrRadioNodeList {\n}\n\npublic external @marker interface UnionHTMLOptGroupElementOrHTMLOptionElement {\n}\n\npublic external @marker interface UnionAudioTrackOrTextTrackOrVideoTrack {\n}\n\npublic external @marker interface UnionElementOrMouseEvent {\n}\n\npublic external @marker interface UnionMessagePortOrWindow {\n}\n\npublic external @marker interface UnionMessagePortOrServiceWorker {\n}\n\npublic external @marker interface HTMLOrSVGScriptElement {\n}\n\npublic external @marker interface RenderingContext {\n}\n\npublic external @marker interface HTMLOrSVGImageElement {\n}\n\n/* please, don't implement this interface! */\npublic external interface DocumentReadyState {\n    companion object\n}\npublic inline val DocumentReadyState.Companion.LOADING: DocumentReadyState get() = \"loading\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.INTERACTIVE: DocumentReadyState get() = \"interactive\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.COMPLETE: DocumentReadyState get() = \"complete\".asDynamic().unsafeCast<DocumentReadyState>()\n\n/* please, don't implement this interface! */\npublic external interface CanPlayTypeResult {\n    companion object\n}\npublic inline val CanPlayTypeResult.Companion.EMPTY: CanPlayTypeResult get() = \"\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.MAYBE: CanPlayTypeResult get() = \"maybe\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.PROBABLY: CanPlayTypeResult get() = \"probably\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackMode {\n    companion object\n}\npublic inline val TextTrackMode.Companion.DISABLED: TextTrackMode get() = \"disabled\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.HIDDEN: TextTrackMode get() = \"hidden\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.SHOWING: TextTrackMode get() = \"showing\".asDynamic().unsafeCast<TextTrackMode>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackKind {\n    companion object\n}\npublic inline val TextTrackKind.Companion.SUBTITLES: TextTrackKind get() = \"subtitles\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CAPTIONS: TextTrackKind get() = \"captions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.DESCRIPTIONS: TextTrackKind get() = \"descriptions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CHAPTERS: TextTrackKind get() = \"chapters\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.METADATA: TextTrackKind get() = \"metadata\".asDynamic().unsafeCast<TextTrackKind>()\n\n/* please, don't implement this interface! */\npublic external interface SelectionMode {\n    companion object\n}\npublic inline val SelectionMode.Companion.SELECT: SelectionMode get() = \"select\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.START: SelectionMode get() = \"start\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.END: SelectionMode get() = \"end\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.PRESERVE: SelectionMode get() = \"preserve\".asDynamic().unsafeCast<SelectionMode>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasFillRule {\n    companion object\n}\npublic inline val CanvasFillRule.Companion.NONZERO: CanvasFillRule get() = \"nonzero\".asDynamic().unsafeCast<CanvasFillRule>()\npublic inline val CanvasFillRule.Companion.EVENODD: CanvasFillRule get() = \"evenodd\".asDynamic().unsafeCast<CanvasFillRule>()\n\n/* please, don't implement this interface! */\npublic external interface ImageSmoothingQuality {\n    companion object\n}\npublic inline val ImageSmoothingQuality.Companion.LOW: ImageSmoothingQuality get() = \"low\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.MEDIUM: ImageSmoothingQuality get() = \"medium\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.HIGH: ImageSmoothingQuality get() = \"high\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineCap {\n    companion object\n}\npublic inline val CanvasLineCap.Companion.BUTT: CanvasLineCap get() = \"butt\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.ROUND: CanvasLineCap get() = \"round\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.SQUARE: CanvasLineCap get() = \"square\".asDynamic().unsafeCast<CanvasLineCap>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineJoin {\n    companion object\n}\npublic inline val CanvasLineJoin.Companion.ROUND: CanvasLineJoin get() = \"round\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.BEVEL: CanvasLineJoin get() = \"bevel\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.MITER: CanvasLineJoin get() = \"miter\".asDynamic().unsafeCast<CanvasLineJoin>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextAlign {\n    companion object\n}\npublic inline val CanvasTextAlign.Companion.START: CanvasTextAlign get() = \"start\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.END: CanvasTextAlign get() = \"end\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.LEFT: CanvasTextAlign get() = \"left\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.RIGHT: CanvasTextAlign get() = \"right\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.CENTER: CanvasTextAlign get() = \"center\".asDynamic().unsafeCast<CanvasTextAlign>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextBaseline {\n    companion object\n}\npublic inline val CanvasTextBaseline.Companion.TOP: CanvasTextBaseline get() = \"top\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.HANGING: CanvasTextBaseline get() = \"hanging\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.MIDDLE: CanvasTextBaseline get() = \"middle\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.ALPHABETIC: CanvasTextBaseline get() = \"alphabetic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.IDEOGRAPHIC: CanvasTextBaseline get() = \"ideographic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.BOTTOM: CanvasTextBaseline get() = \"bottom\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasDirection {\n    companion object\n}\npublic inline val CanvasDirection.Companion.LTR: CanvasDirection get() = \"ltr\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.RTL: CanvasDirection get() = \"rtl\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.INHERIT: CanvasDirection get() = \"inherit\".asDynamic().unsafeCast<CanvasDirection>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollRestoration {\n    companion object\n}\npublic inline val ScrollRestoration.Companion.AUTO: ScrollRestoration get() = \"auto\".asDynamic().unsafeCast<ScrollRestoration>()\npublic inline val ScrollRestoration.Companion.MANUAL: ScrollRestoration get() = \"manual\".asDynamic().unsafeCast<ScrollRestoration>()\n\n/* please, don't implement this interface! */\npublic external interface ImageOrientation {\n    companion object\n}\npublic inline val ImageOrientation.Companion.NONE: ImageOrientation get() = \"none\".asDynamic().unsafeCast<ImageOrientation>()\npublic inline val ImageOrientation.Companion.FLIPY: ImageOrientation get() = \"flipY\".asDynamic().unsafeCast<ImageOrientation>()\n\n/* please, don't implement this interface! */\npublic external interface PremultiplyAlpha {\n    companion object\n}\npublic inline val PremultiplyAlpha.Companion.NONE: PremultiplyAlpha get() = \"none\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.PREMULTIPLY: PremultiplyAlpha get() = \"premultiply\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.DEFAULT: PremultiplyAlpha get() = \"default\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\n/* please, don't implement this interface! */\npublic external interface ColorSpaceConversion {\n    companion object\n}\npublic inline val ColorSpaceConversion.Companion.NONE: ColorSpaceConversion get() = \"none\".asDynamic().unsafeCast<ColorSpaceConversion>()\npublic inline val ColorSpaceConversion.Companion.DEFAULT: ColorSpaceConversion get() = \"default\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\n/* please, don't implement this interface! */\npublic external interface ResizeQuality {\n    companion object\n}\npublic inline val ResizeQuality.Companion.PIXELATED: ResizeQuality get() = \"pixelated\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.LOW: ResizeQuality get() = \"low\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.MEDIUM: ResizeQuality get() = \"medium\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.HIGH: ResizeQuality get() = \"high\".asDynamic().unsafeCast<ResizeQuality>()\n\n/* please, don't implement this interface! */\npublic external interface BinaryType {\n    companion object\n}\npublic inline val BinaryType.Companion.BLOB: BinaryType get() = \"blob\".asDynamic().unsafeCast<BinaryType>()\npublic inline val BinaryType.Companion.ARRAYBUFFER: BinaryType get() = \"arraybuffer\".asDynamic().unsafeCast<BinaryType>()\n\n/* please, don't implement this interface! */\npublic external interface WorkerType {\n    companion object\n}\npublic inline val WorkerType.Companion.CLASSIC: WorkerType get() = \"classic\".asDynamic().unsafeCast<WorkerType>()\npublic inline val WorkerType.Companion.MODULE: WorkerType get() = \"module\".asDynamic().unsafeCast<WorkerType>()\n\n/* please, don't implement this interface! */\npublic external interface ShadowRootMode {\n    companion object\n}\npublic inline val ShadowRootMode.Companion.OPEN: ShadowRootMode get() = \"open\".asDynamic().unsafeCast<ShadowRootMode>()\npublic inline val ShadowRootMode.Companion.CLOSED: ShadowRootMode get() = \"closed\".asDynamic().unsafeCast<ShadowRootMode>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollBehavior {\n    companion object\n}\npublic inline val ScrollBehavior.Companion.AUTO: ScrollBehavior get() = \"auto\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.INSTANT: ScrollBehavior get() = \"instant\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.SMOOTH: ScrollBehavior get() = \"smooth\".asDynamic().unsafeCast<ScrollBehavior>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollLogicalPosition {\n    companion object\n}\npublic inline val ScrollLogicalPosition.Companion.START: ScrollLogicalPosition get() = \"start\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.CENTER: ScrollLogicalPosition get() = \"center\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.END: ScrollLogicalPosition get() = \"end\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.NEAREST: ScrollLogicalPosition get() = \"nearest\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\n/* please, don't implement this interface! */\npublic external interface CSSBoxType {\n    companion object\n}\npublic inline val CSSBoxType.Companion.MARGIN: CSSBoxType get() = \"margin\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.BORDER: CSSBoxType get() = \"border\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.PADDING: CSSBoxType get() = \"padding\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.CONTENT: CSSBoxType get() = \"content\".asDynamic().unsafeCast<CSSBoxType>()\n\n"],"names":[],"mappings":"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"}